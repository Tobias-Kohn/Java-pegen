/*
 * @generated by pegen from data/python.gram
 */
package org.python.parser;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

class GeneratedParser<T> extends Parser<T> {

    GeneratedParser(Tokenizer tokenizer, String filename, boolean verbose, AstFactory<T> ast) {
        super(tokenizer, filename, verbose, ast);
    }

    private static class Memo<T_> {
        public final T_ item;
        public int end_mark;

        Memo(T_ item, int end_mark) {
            this.item = item;
            this.end_mark = end_mark;
        }

        @Override
        public String toString() {
            if (item != null)
                return item.toString() + ":~" + end_mark;
            else
                return "<null>:~" + end_mark;
        }
    }

    private final Map<Integer, Memo<T>> start_cache = new HashMap<>();

    protected T start() {
        int p = this.mark();
        Memo<T> info = start_cache.get(p);
        if (info != null) {
            log("start() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("start() ...");
        this._level += 1;
        T result = _start();
        this._level -= 1;
        log("start() [fresh]-> ", result);
        if (result != null) {
            start_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _start() {
        // start: file
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T file;
            if (
                    (file = this.file()) != null
            ) {
                return file;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> file_cache = new HashMap<>();

    protected T file() {
        int p = this.mark();
        Memo<T> info = file_cache.get(p);
        if (info != null) {
            log("file() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("file() ...");
        this._level += 1;
        T result = _file();
        this._level -= 1;
        log("file() [fresh]-> ", result);
        if (result != null) {
            file_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _file() {
        // file: statements? $
        // type: mod_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            if (
                    ((a = this.statements()) != null || true)
                            &&
                            this.expect(TokenType.ENDMARKER) != null
            ) {
                return ast.make_module ( a );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> interactive_cache = new HashMap<>();

    protected T interactive() {
        int p = this.mark();
        Memo<T> info = interactive_cache.get(p);
        if (info != null) {
            log("interactive() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("interactive() ...");
        this._level += 1;
        T result = _interactive();
        this._level -= 1;
        log("interactive() [fresh]-> ", result);
        if (result != null) {
            interactive_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _interactive() {
        // interactive: statement_newline
        // type: mod_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            if (
                    (a = this.statement_newline()) != null
            ) {
                return ast.Interactive ( a );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> eval_cache = new HashMap<>();

    protected T eval() {
        int p = this.mark();
        Memo<T> info = eval_cache.get(p);
        if (info != null) {
            log("eval() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("eval() ...");
        this._level += 1;
        T result = _eval();
        this._level -= 1;
        log("eval() [fresh]-> ", result);
        if (result != null) {
            eval_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _eval() {
        // eval: expressions NEWLINE* $
        // type: mod_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            T[] _loop0_1;
            if (
                    (a = this.expressions()) != null
                            &&
                            (_loop0_1 = this._loop0_1()) != null
                            &&
                            this.expect(TokenType.ENDMARKER) != null
            ) {
                return ast.Expression ( a );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> func_type_cache = new HashMap<>();

    protected T func_type() {
        int p = this.mark();
        Memo<T> info = func_type_cache.get(p);
        if (info != null) {
            log("func_type() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("func_type() ...");
        this._level += 1;
        T result = _func_type();
        this._level -= 1;
        log("func_type() [fresh]-> ", result);
        if (result != null) {
            func_type_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _func_type() {
        // func_type: '(' type_expressions? ')' '->' expression NEWLINE* $
        // type: mod_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T[] a;
            Token literal_1;
            Token literal_2;
            T b;
            T[] _loop0_2;
            if (
                    (literal = this.expectStr('(')) != null
                            &&
                            ((a = this.type_expressions()) != null || true)
                            &&
                            (literal_1 = this.expectStr(')')) != null
                            &&
                            (literal_2 = this.expectStr("->")) != null
                            &&
                            (b = this.expression()) != null
                            &&
                            (_loop0_2 = this._loop0_2()) != null
                            &&
                            this.expect(TokenType.ENDMARKER) != null
            ) {
                return ast.FunctionType ( a , b );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> fstring_cache = new HashMap<>();

    protected T fstring() {
        int p = this.mark();
        Memo<T> info = fstring_cache.get(p);
        if (info != null) {
            log("fstring() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("fstring() ...");
        this._level += 1;
        T result = _fstring();
        this._level -= 1;
        log("fstring() [fresh]-> ", result);
        if (result != null) {
            fstring_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _fstring() {
        // fstring: star_expressions
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T star_expressions;
            if (
                    (star_expressions = this.star_expressions()) != null
            ) {
                return star_expressions;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> type_expressions_cache = new HashMap<>();

    protected T[] type_expressions() {
        int p = this.mark();
        Memo<T[]> info = type_expressions_cache.get(p);
        if (info != null) {
            log("type_expressions() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("type_expressions() ...");
        this._level += 1;
        T[] result = _type_expressions();
        this._level -= 1;
        log("type_expressions() [fresh]-> ", result);
        if (result != null) {
            type_expressions_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _type_expressions() {
        // type_expressions: ','.expression+ ',' '*' expression ',' '**' expression | ','.expression+ ',' '*' expression | ','.expression+ ',' '**' expression | '*' expression ',' '**' expression | '*' expression | '**' expression | ','.expression+
        // type: asdl_expr_seq*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            Token literal;
            Token literal_1;
            T b;
            Token literal_2;
            Token literal_3;
            T c;
            if (
                    (a = this._gather_3()) != null
                            &&
                            (literal = this.expectStr(',')) != null
                            &&
                            (literal_1 = this.expectStr('*')) != null
                            &&
                            (b = this.expression()) != null
                            &&
                            (literal_2 = this.expectStr(',')) != null
                            &&
                            (literal_3 = this.expectStr("**")) != null
                            &&
                            (c = this.expression()) != null
            ) {
                return ast.seq_append_to_end ( ast.seq_append_to_end ( a , b ) , c );
            }
            this.reset(mark);
        }
        {
            T[] a;
            Token literal;
            Token literal_1;
            T b;
            if (
                    (a = this._gather_5()) != null
                            &&
                            (literal = this.expectStr(',')) != null
                            &&
                            (literal_1 = this.expectStr('*')) != null
                            &&
                            (b = this.expression()) != null
            ) {
                return ast.seq_append_to_end ( a , b );
            }
            this.reset(mark);
        }
        {
            T[] a;
            Token literal;
            Token literal_1;
            T b;
            if (
                    (a = this._gather_7()) != null
                            &&
                            (literal = this.expectStr(',')) != null
                            &&
                            (literal_1 = this.expectStr("**")) != null
                            &&
                            (b = this.expression()) != null
            ) {
                return ast.seq_append_to_end ( a , b );
            }
            this.reset(mark);
        }
        {
            Token literal;
            T a;
            Token literal_1;
            Token literal_2;
            T b;
            if (
                    (literal = this.expectStr('*')) != null
                            &&
                            (a = this.expression()) != null
                            &&
                            (literal_1 = this.expectStr(',')) != null
                            &&
                            (literal_2 = this.expectStr("**")) != null
                            &&
                            (b = this.expression()) != null
            ) {
                return ast.seq_append_to_end ( ast.singleton_seq ( a ) , b );
            }
            this.reset(mark);
        }
        {
            Token literal;
            T a;
            if (
                    (literal = this.expectStr('*')) != null
                            &&
                            (a = this.expression()) != null
            ) {
                return ast.singleton_seq ( a );
            }
            this.reset(mark);
        }
        {
            Token literal;
            T a;
            if (
                    (literal = this.expectStr("**")) != null
                            &&
                            (a = this.expression()) != null
            ) {
                return ast.singleton_seq ( a );
            }
            this.reset(mark);
        }
        {
            T[] a;
            if (
                    (a = this._gather_9()) != null
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> statements_cache = new HashMap<>();

    protected T[] statements() {
        int p = this.mark();
        Memo<T[]> info = statements_cache.get(p);
        if (info != null) {
            log("statements() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("statements() ...");
        this._level += 1;
        T[] result = _statements();
        this._level -= 1;
        log("statements() [fresh]-> ", result);
        if (result != null) {
            statements_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _statements() {
        // statements: statement+
        // type: asdl_stmt_seq*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            if (
                    (a = null_if_empty(this._loop1_11())) != null
            ) {
                return ast.seq_flatten ( a );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> statement_cache = new HashMap<>();

    protected T[] statement() {
        int p = this.mark();
        Memo<T[]> info = statement_cache.get(p);
        if (info != null) {
            log("statement() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("statement() ...");
        this._level += 1;
        T[] result = _statement();
        this._level -= 1;
        log("statement() [fresh]-> ", result);
        if (result != null) {
            statement_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _statement() {
        // statement: compound_stmt | simple_stmt
        // type: asdl_stmt_seq*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            if (
                    (a = this.compound_stmt()) != null
            ) {
                return ast.singleton_seq ( a );
            }
            this.reset(mark);
        }
        {
            T[] a;
            if (
                    (a = this.simple_stmt()) != null
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> statement_newline_cache = new HashMap<>();

    protected T[] statement_newline() {
        int p = this.mark();
        Memo<T[]> info = statement_newline_cache.get(p);
        if (info != null) {
            log("statement_newline() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("statement_newline() ...");
        this._level += 1;
        T[] result = _statement_newline();
        this._level -= 1;
        log("statement_newline() [fresh]-> ", result);
        if (result != null) {
            statement_newline_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _statement_newline() {
        // statement_newline: compound_stmt NEWLINE | simple_stmt | NEWLINE | $
        // type: asdl_stmt_seq*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            if (
                    (a = this.compound_stmt()) != null
                            &&
                            this.expect(TokenType.NEWLINE) != null
            ) {
                return ast.singleton_seq ( a );
            }
            this.reset(mark);
        }
        {
            T[] simple_stmt;
            if (
                    (simple_stmt = this.simple_stmt()) != null
            ) {
                return simple_stmt;
            }
            this.reset(mark);
        }
        {
            if (
                    this.expect(TokenType.NEWLINE) != null
            ) {
                return ast.singleton_seq ( ast.Pass ( line_no , col_offset ) );
            }
            this.reset(mark);
        }
        {
            if (
                    this.expect(TokenType.ENDMARKER) != null
            ) {
                return ast.interactive_exit ( );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> simple_stmt_cache = new HashMap<>();

    protected T[] simple_stmt() {
        int p = this.mark();
        Memo<T[]> info = simple_stmt_cache.get(p);
        if (info != null) {
            log("simple_stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("simple_stmt() ...");
        this._level += 1;
        T[] result = _simple_stmt();
        this._level -= 1;
        log("simple_stmt() [fresh]-> ", result);
        if (result != null) {
            simple_stmt_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _simple_stmt() {
        // simple_stmt: small_stmt !';' NEWLINE | ';'.small_stmt+ ';'? NEWLINE
        // type: asdl_stmt_seq*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            if (
                    (a = this.small_stmt()) != null
                            &&
                            this.negative_lookahead(this::expectStr, ';')
                            &&
                            this.expect(TokenType.NEWLINE) != null
            ) {
                return ast.singleton_seq ( a );
            }
            this.reset(mark);
        }
        {
            T[] a;
            Token literal;
            if (
                    (a = this._gather_12()) != null
                            &&
                            ((literal = this.expectStr(';')) != null || true)
                            &&
                            this.expect(TokenType.NEWLINE) != null
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> small_stmt_cache = new HashMap<>();

    protected T small_stmt() {
        int p = this.mark();
        Memo<T> info = small_stmt_cache.get(p);
        if (info != null) {
            log("small_stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("small_stmt() ...");
        this._level += 1;
        T result = _small_stmt();
        this._level -= 1;
        log("small_stmt() [fresh]-> ", result);
        if (result != null) {
            small_stmt_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _small_stmt() {
        // small_stmt: assignment | star_expressions | &'return' return_stmt | &('import' | 'from') import_stmt | &'raise' raise_stmt | 'pass' | &'del' del_stmt | &'yield' yield_stmt | &'assert' assert_stmt | 'break' | 'continue' | &'global' global_stmt | &'nonlocal' nonlocal_stmt
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T assignment;
            if (
                    (assignment = this.assignment()) != null
            ) {
                return assignment;
            }
            this.reset(mark);
        }
        {
            T e;
            if (
                    (e = this.star_expressions()) != null
            ) {
                return ast.Expr ( e , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T return_stmt;
            if (
                    this.positive_lookahead(this::expectKeyword, "return")
                            &&
                            (return_stmt = this.return_stmt()) != null
            ) {
                return return_stmt;
            }
            this.reset(mark);
        }
        {
            T import_stmt;
            if (
                    this.positive_lookahead(this::_tmp_14)
                            &&
                            (import_stmt = this.import_stmt()) != null
            ) {
                return import_stmt;
            }
            this.reset(mark);
        }
        {
            T raise_stmt;
            if (
                    this.positive_lookahead(this::expectKeyword, "raise")
                            &&
                            (raise_stmt = this.raise_stmt()) != null
            ) {
                return raise_stmt;
            }
            this.reset(mark);
        }
        {
            if (
                    this.expectKeyword("pass") != null
            ) {
                return ast.Pass ( line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T del_stmt;
            if (
                    this.positive_lookahead(this::expectKeyword, "del")
                            &&
                            (del_stmt = this.del_stmt()) != null
            ) {
                return del_stmt;
            }
            this.reset(mark);
        }
        {
            T yield_stmt;
            if (
                    this.positive_lookahead(this::expectKeyword, "yield")
                            &&
                            (yield_stmt = this.yield_stmt()) != null
            ) {
                return yield_stmt;
            }
            this.reset(mark);
        }
        {
            T assert_stmt;
            if (
                    this.positive_lookahead(this::expectKeyword, "assert")
                            &&
                            (assert_stmt = this.assert_stmt()) != null
            ) {
                return assert_stmt;
            }
            this.reset(mark);
        }
        {
            if (
                    this.expectKeyword("break") != null
            ) {
                return ast.Break ( line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            if (
                    this.expectKeyword("continue") != null
            ) {
                return ast.Continue ( line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T global_stmt;
            if (
                    this.positive_lookahead(this::expectKeyword, "global")
                            &&
                            (global_stmt = this.global_stmt()) != null
            ) {
                return global_stmt;
            }
            this.reset(mark);
        }
        {
            T nonlocal_stmt;
            if (
                    this.positive_lookahead(this::expectKeyword, "nonlocal")
                            &&
                            (nonlocal_stmt = this.nonlocal_stmt()) != null
            ) {
                return nonlocal_stmt;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> compound_stmt_cache = new HashMap<>();

    protected T compound_stmt() {
        int p = this.mark();
        Memo<T> info = compound_stmt_cache.get(p);
        if (info != null) {
            log("compound_stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("compound_stmt() ...");
        this._level += 1;
        T result = _compound_stmt();
        this._level -= 1;
        log("compound_stmt() [fresh]-> ", result);
        if (result != null) {
            compound_stmt_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _compound_stmt() {
        // compound_stmt: &('def' | '@' | ASYNC) function_def | &'if' if_stmt | &('class' | '@') class_def | &('with' | ASYNC) with_stmt | &('for' | ASYNC) for_stmt | &'try' try_stmt | &'while' while_stmt
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T function_def;
            if (
                    this.positive_lookahead(this::_tmp_15)
                            &&
                            (function_def = this.function_def()) != null
            ) {
                return function_def;
            }
            this.reset(mark);
        }
        {
            T if_stmt;
            if (
                    this.positive_lookahead(this::expectKeyword, "if")
                            &&
                            (if_stmt = this.if_stmt()) != null
            ) {
                return if_stmt;
            }
            this.reset(mark);
        }
        {
            T class_def;
            if (
                    this.positive_lookahead(this::_tmp_16)
                            &&
                            (class_def = this.class_def()) != null
            ) {
                return class_def;
            }
            this.reset(mark);
        }
        {
            T with_stmt;
            if (
                    this.positive_lookahead(this::_tmp_17)
                            &&
                            (with_stmt = this.with_stmt()) != null
            ) {
                return with_stmt;
            }
            this.reset(mark);
        }
        {
            T for_stmt;
            if (
                    this.positive_lookahead(this::_tmp_18)
                            &&
                            (for_stmt = this.for_stmt()) != null
            ) {
                return for_stmt;
            }
            this.reset(mark);
        }
        {
            T try_stmt;
            if (
                    this.positive_lookahead(this::expectKeyword, "try")
                            &&
                            (try_stmt = this.try_stmt()) != null
            ) {
                return try_stmt;
            }
            this.reset(mark);
        }
        {
            T while_stmt;
            if (
                    this.positive_lookahead(this::expectKeyword, "while")
                            &&
                            (while_stmt = this.while_stmt()) != null
            ) {
                return while_stmt;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> assignment_cache = new HashMap<>();

    protected T assignment() {
        int p = this.mark();
        Memo<T> info = assignment_cache.get(p);
        if (info != null) {
            log("assignment() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("assignment() ...");
        this._level += 1;
        T result = _assignment();
        this._level -= 1;
        log("assignment() [fresh]-> ", result);
        if (result != null) {
            assignment_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _assignment() {
        // assignment: NAME ':' expression ['=' annotated_rhs] | ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs] | ((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT? | single_target augassign ~ (yield_expr | star_expressions)
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T b;
            T c;
            if (
                    (a = this.name()) != null
                            &&
                            (literal = this.expectStr(':')) != null
                            &&
                            (b = this.expression()) != null
                            &&
                            ((c = this._tmp_19()) != null || true)
            ) {
                return ast.AnnAssign ( ast.set_expr_context ( a , ast.Store() ) , b , c , 1 , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            Token literal;
            T b;
            T c;
            if (
                    (a = this._tmp_20()) != null
                            &&
                            (literal = this.expectStr(':')) != null
                            &&
                            (b = this.expression()) != null
                            &&
                            ((c = this._tmp_21()) != null || true)
            ) {
                return ast.AnnAssign ( a , b , c , 0 , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T[] a;
            T b;
            Token tc;
            if (
                    (a = null_if_empty(this._loop1_22())) != null
                            &&
                            (b = this._tmp_23()) != null
                            &&
                            this.negative_lookahead(this::expectStr, '=')
                            &&
                            ((tc = this.expect(TokenType.TYPE_COMMENT)) != null || true)
            ) {
                return ast.Assign ( a , b , ast.type_comment ( tc ) , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            T b;
            T c;
            if (
                    (a = this.single_target()) != null
                            &&
                            (b = this.augassign()) != null
                            &&
                            (cut = true)
                            &&
                            (c = this._tmp_24()) != null
            ) {
                return ast.AugAssign ( a , b , c , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> augassign_cache = new HashMap<>();

    protected T augassign() {
        int p = this.mark();
        Memo<T> info = augassign_cache.get(p);
        if (info != null) {
            log("augassign() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("augassign() ...");
        this._level += 1;
        T result = _augassign();
        this._level -= 1;
        log("augassign() [fresh]-> ", result);
        if (result != null) {
            augassign_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _augassign() {
        // augassign: '+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '**=' | '//='
        // type: AugOperator*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            if (
                    (literal = this.expectStr("+=")) != null
            ) {
                return ast.augoperator ( ast.Add() );
            }
            this.reset(mark);
        }
        {
            Token literal;
            if (
                    (literal = this.expectStr("-=")) != null
            ) {
                return ast.augoperator ( ast.Sub() );
            }
            this.reset(mark);
        }
        {
            Token literal;
            if (
                    (literal = this.expectStr("*=")) != null
            ) {
                return ast.augoperator ( ast.Mult() );
            }
            this.reset(mark);
        }
        {
            Token literal;
            if (
                    (literal = this.expectStr("@=")) != null
            ) {
                return ast.augoperator ( ast.MatMult() );
            }
            this.reset(mark);
        }
        {
            Token literal;
            if (
                    (literal = this.expectStr("/=")) != null
            ) {
                return ast.augoperator ( ast.Div() );
            }
            this.reset(mark);
        }
        {
            Token literal;
            if (
                    (literal = this.expectStr("%=")) != null
            ) {
                return ast.augoperator ( ast.Mod() );
            }
            this.reset(mark);
        }
        {
            Token literal;
            if (
                    (literal = this.expectStr("&=")) != null
            ) {
                return ast.augoperator ( ast.BitAnd() );
            }
            this.reset(mark);
        }
        {
            Token literal;
            if (
                    (literal = this.expectStr("|=")) != null
            ) {
                return ast.augoperator ( ast.BitOr() );
            }
            this.reset(mark);
        }
        {
            Token literal;
            if (
                    (literal = this.expectStr("^=")) != null
            ) {
                return ast.augoperator ( ast.BitXor() );
            }
            this.reset(mark);
        }
        {
            Token literal;
            if (
                    (literal = this.expectStr("<<=")) != null
            ) {
                return ast.augoperator ( ast.LShift() );
            }
            this.reset(mark);
        }
        {
            Token literal;
            if (
                    (literal = this.expectStr(">>=")) != null
            ) {
                return ast.augoperator ( ast.RShift() );
            }
            this.reset(mark);
        }
        {
            Token literal;
            if (
                    (literal = this.expectStr("**=")) != null
            ) {
                return ast.augoperator ( ast.Pow() );
            }
            this.reset(mark);
        }
        {
            Token literal;
            if (
                    (literal = this.expectStr("//=")) != null
            ) {
                return ast.augoperator ( ast.FloorDiv() );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> global_stmt_cache = new HashMap<>();

    protected T global_stmt() {
        int p = this.mark();
        Memo<T> info = global_stmt_cache.get(p);
        if (info != null) {
            log("global_stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("global_stmt() ...");
        this._level += 1;
        T result = _global_stmt();
        this._level -= 1;
        log("global_stmt() [fresh]-> ", result);
        if (result != null) {
            global_stmt_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _global_stmt() {
        // global_stmt: 'global' ','.NAME+
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            if (
                    this.expectKeyword("global") != null
                            &&
                            (a = this._gather_25()) != null
            ) {
                return ast.Global ( ast.map_names_to_ids ( a ) , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> nonlocal_stmt_cache = new HashMap<>();

    protected T nonlocal_stmt() {
        int p = this.mark();
        Memo<T> info = nonlocal_stmt_cache.get(p);
        if (info != null) {
            log("nonlocal_stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("nonlocal_stmt() ...");
        this._level += 1;
        T result = _nonlocal_stmt();
        this._level -= 1;
        log("nonlocal_stmt() [fresh]-> ", result);
        if (result != null) {
            nonlocal_stmt_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _nonlocal_stmt() {
        // nonlocal_stmt: 'nonlocal' ','.NAME+
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            if (
                    this.expectKeyword("nonlocal") != null
                            &&
                            (a = this._gather_27()) != null
            ) {
                return ast.Nonlocal ( ast.map_names_to_ids ( a ) , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> yield_stmt_cache = new HashMap<>();

    protected T yield_stmt() {
        int p = this.mark();
        Memo<T> info = yield_stmt_cache.get(p);
        if (info != null) {
            log("yield_stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("yield_stmt() ...");
        this._level += 1;
        T result = _yield_stmt();
        this._level -= 1;
        log("yield_stmt() [fresh]-> ", result);
        if (result != null) {
            yield_stmt_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _yield_stmt() {
        // yield_stmt: yield_expr
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T y;
            if (
                    (y = this.yield_expr()) != null
            ) {
                return ast.Expr ( y , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> assert_stmt_cache = new HashMap<>();

    protected T assert_stmt() {
        int p = this.mark();
        Memo<T> info = assert_stmt_cache.get(p);
        if (info != null) {
            log("assert_stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("assert_stmt() ...");
        this._level += 1;
        T result = _assert_stmt();
        this._level -= 1;
        log("assert_stmt() [fresh]-> ", result);
        if (result != null) {
            assert_stmt_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _assert_stmt() {
        // assert_stmt: 'assert' expression [',' expression]
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            T b;
            if (
                    this.expectKeyword("assert") != null
                            &&
                            (a = this.expression()) != null
                            &&
                            ((b = this._tmp_29()) != null || true)
            ) {
                return ast.Assert ( a , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> del_stmt_cache = new HashMap<>();

    protected T del_stmt() {
        int p = this.mark();
        Memo<T> info = del_stmt_cache.get(p);
        if (info != null) {
            log("del_stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("del_stmt() ...");
        this._level += 1;
        T result = _del_stmt();
        this._level -= 1;
        log("del_stmt() [fresh]-> ", result);
        if (result != null) {
            del_stmt_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _del_stmt() {
        // del_stmt: 'del' del_targets &(';' | NEWLINE)
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            if (
                    this.expectKeyword("del") != null
                            &&
                            (a = this.del_targets()) != null
                            &&
                            this.positive_lookahead(this::_tmp_30)
            ) {
                return ast.Delete ( a , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> import_stmt_cache = new HashMap<>();

    protected T import_stmt() {
        int p = this.mark();
        Memo<T> info = import_stmt_cache.get(p);
        if (info != null) {
            log("import_stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("import_stmt() ...");
        this._level += 1;
        T result = _import_stmt();
        this._level -= 1;
        log("import_stmt() [fresh]-> ", result);
        if (result != null) {
            import_stmt_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _import_stmt() {
        // import_stmt: import_name | import_from
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T import_name;
            if (
                    (import_name = this.import_name()) != null
            ) {
                return import_name;
            }
            this.reset(mark);
        }
        {
            T import_from;
            if (
                    (import_from = this.import_from()) != null
            ) {
                return import_from;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> import_name_cache = new HashMap<>();

    protected T import_name() {
        int p = this.mark();
        Memo<T> info = import_name_cache.get(p);
        if (info != null) {
            log("import_name() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("import_name() ...");
        this._level += 1;
        T result = _import_name();
        this._level -= 1;
        log("import_name() [fresh]-> ", result);
        if (result != null) {
            import_name_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _import_name() {
        // import_name: 'import' dotted_as_names
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            if (
                    this.expectKeyword("import") != null
                            &&
                            (a = this.dotted_as_names()) != null
            ) {
                return ast.Import ( a , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> import_from_cache = new HashMap<>();

    protected T import_from() {
        int p = this.mark();
        Memo<T> info = import_from_cache.get(p);
        if (info != null) {
            log("import_from() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("import_from() ...");
        this._level += 1;
        T result = _import_from();
        this._level -= 1;
        log("import_from() [fresh]-> ", result);
        if (result != null) {
            import_from_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _import_from() {
        // import_from: 'from' (('.' | '...'))* dotted_name 'import' import_from_targets | 'from' (('.' | '...'))+ 'import' import_from_targets
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            T b;
            T[] c;
            if (
                    this.expectKeyword("from") != null
                            &&
                            (a = this._loop0_31()) != null
                            &&
                            (b = this.dotted_name()) != null
                            &&
                            this.expectKeyword("import") != null
                            &&
                            (c = this.import_from_targets()) != null
            ) {
                return ast.ImportFrom ( ast.get_expr_name(b) , c , ast.seq_count_dots ( a ) , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T[] a;
            T[] b;
            if (
                    this.expectKeyword("from") != null
                            &&
                            (a = null_if_empty(this._loop1_32())) != null
                            &&
                            this.expectKeyword("import") != null
                            &&
                            (b = this.import_from_targets()) != null
            ) {
                return ast.ImportFrom ( null , b , ast.seq_count_dots ( a ) , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> import_from_targets_cache = new HashMap<>();

    protected T[] import_from_targets() {
        int p = this.mark();
        Memo<T[]> info = import_from_targets_cache.get(p);
        if (info != null) {
            log("import_from_targets() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("import_from_targets() ...");
        this._level += 1;
        T[] result = _import_from_targets();
        this._level -= 1;
        log("import_from_targets() [fresh]-> ", result);
        if (result != null) {
            import_from_targets_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _import_from_targets() {
        // import_from_targets: '(' import_from_as_names ','? ')' | import_from_as_names !',' | '*'
        // type: asdl_alias_seq*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T[] a;
            Token literal_1;
            Token literal_2;
            if (
                    (literal = this.expectStr('(')) != null
                            &&
                            (a = this.import_from_as_names()) != null
                            &&
                            ((literal_1 = this.expectStr(',')) != null || true)
                            &&
                            (literal_2 = this.expectStr(')')) != null
            ) {
                return a;
            }
            this.reset(mark);
        }
        {
            T[] import_from_as_names;
            if (
                    (import_from_as_names = this.import_from_as_names()) != null
                            &&
                            this.negative_lookahead(this::expectStr, ',')
            ) {
                return import_from_as_names;
            }
            this.reset(mark);
        }
        {
            Token literal;
            if (
                    (literal = this.expectStr('*')) != null
            ) {
                return ast.singleton_seq ( ast.alias_for_star ( ) );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> import_from_as_names_cache = new HashMap<>();

    protected T[] import_from_as_names() {
        int p = this.mark();
        Memo<T[]> info = import_from_as_names_cache.get(p);
        if (info != null) {
            log("import_from_as_names() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("import_from_as_names() ...");
        this._level += 1;
        T[] result = _import_from_as_names();
        this._level -= 1;
        log("import_from_as_names() [fresh]-> ", result);
        if (result != null) {
            import_from_as_names_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _import_from_as_names() {
        // import_from_as_names: ','.import_from_as_name+
        // type: asdl_alias_seq*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            if (
                    (a = this._gather_33()) != null
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> import_from_as_name_cache = new HashMap<>();

    protected T import_from_as_name() {
        int p = this.mark();
        Memo<T> info = import_from_as_name_cache.get(p);
        if (info != null) {
            log("import_from_as_name() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("import_from_as_name() ...");
        this._level += 1;
        T result = _import_from_as_name();
        this._level -= 1;
        log("import_from_as_name() [fresh]-> ", result);
        if (result != null) {
            import_from_as_name_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _import_from_as_name() {
        // import_from_as_name: NAME ['as' NAME]
        // type: alias_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            T b;
            if (
                    (a = this.name()) != null
                            &&
                            ((b = this._tmp_35()) != null || true)
            ) {
                return ast.alias ( ast.get_expr_name(a) , (b != null) ? ast.get_expr_name(b) : null );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> dotted_as_names_cache = new HashMap<>();

    protected T[] dotted_as_names() {
        int p = this.mark();
        Memo<T[]> info = dotted_as_names_cache.get(p);
        if (info != null) {
            log("dotted_as_names() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("dotted_as_names() ...");
        this._level += 1;
        T[] result = _dotted_as_names();
        this._level -= 1;
        log("dotted_as_names() [fresh]-> ", result);
        if (result != null) {
            dotted_as_names_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _dotted_as_names() {
        // dotted_as_names: ','.dotted_as_name+
        // type: asdl_alias_seq*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            if (
                    (a = this._gather_36()) != null
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> dotted_as_name_cache = new HashMap<>();

    protected T dotted_as_name() {
        int p = this.mark();
        Memo<T> info = dotted_as_name_cache.get(p);
        if (info != null) {
            log("dotted_as_name() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("dotted_as_name() ...");
        this._level += 1;
        T result = _dotted_as_name();
        this._level -= 1;
        log("dotted_as_name() [fresh]-> ", result);
        if (result != null) {
            dotted_as_name_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _dotted_as_name() {
        // dotted_as_name: dotted_name ['as' NAME]
        // type: alias_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            T b;
            if (
                    (a = this.dotted_name()) != null
                            &&
                            ((b = this._tmp_38()) != null || true)
            ) {
                return ast.alias ( ast.get_expr_name(a) , (b != null) ? ast.get_expr_name(b) : null );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> dotted_name_cache = new HashMap<>();

    protected T dotted_name() {
        int p = this.mark();
        Memo<T> info = dotted_name_cache.get(p);
        if (info != null) {
            log("dotted_name() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("dotted_name() ...");
        T last_result = null;
        int last_mark = p;
        int depth = 0;
        dotted_name_cache.put(p, new Memo<>(null, p));
        log("recursive dotted_name() at " + p + " depth " + depth);
        while (true) {
            this.reset(p);
            this._level += 1;
            T result = _dotted_name();
            int end_mark = this.mark();
            depth += 1;
            this._level -= 1;
            log("recursive dotted_name() at " + p + " depth " + depth + ": ", result);
            if (result == null || end_mark <= last_mark)
                break;
            last_result = result;
            last_mark = end_mark;
            dotted_name_cache.put(p, new Memo<>(result, end_mark));
        }
        this.reset(last_mark);
        if (last_result != null) {
            last_mark = this.mark();
        } else {
            last_mark = p;
            this.reset(last_mark);
        }
        log("dotted_name() [fresh]-> ", last_result);
        dotted_name_cache.put(p, new Memo<>(last_result, last_mark));
        return last_result;
    }

    private T _dotted_name() {
        // dotted_name: dotted_name '.' NAME | NAME
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.dotted_name()) != null
                            &&
                            (literal = this.expectStr('.')) != null
                            &&
                            (b = this.name()) != null
            ) {
                return ast.join_names_with_dot ( a , b );
            }
            this.reset(mark);
        }
        {
            T name;
            if (
                    (name = this.name()) != null
            ) {
                return name;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> if_stmt_cache = new HashMap<>();

    protected T if_stmt() {
        int p = this.mark();
        Memo<T> info = if_stmt_cache.get(p);
        if (info != null) {
            log("if_stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("if_stmt() ...");
        this._level += 1;
        T result = _if_stmt();
        this._level -= 1;
        log("if_stmt() [fresh]-> ", result);
        if (result != null) {
            if_stmt_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _if_stmt() {
        // if_stmt: 'if' named_expression ':' block elif_stmt | 'if' named_expression ':' block else_block?
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T[] b;
            T c;
            if (
                    this.expectKeyword("if") != null
                            &&
                            (a = this.named_expression()) != null
                            &&
                            (literal = this.expectStr(':')) != null
                            &&
                            (b = this.block()) != null
                            &&
                            (c = this.elif_stmt()) != null
            ) {
                return ast.If ( a , b , ast.singleton_seq ( c ) , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            Token literal;
            T[] b;
            T[] c;
            if (
                    this.expectKeyword("if") != null
                            &&
                            (a = this.named_expression()) != null
                            &&
                            (literal = this.expectStr(':')) != null
                            &&
                            (b = this.block()) != null
                            &&
                            ((c = this.else_block()) != null || true)
            ) {
                return ast.If ( a , b , c , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> elif_stmt_cache = new HashMap<>();

    protected T elif_stmt() {
        int p = this.mark();
        Memo<T> info = elif_stmt_cache.get(p);
        if (info != null) {
            log("elif_stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("elif_stmt() ...");
        this._level += 1;
        T result = _elif_stmt();
        this._level -= 1;
        log("elif_stmt() [fresh]-> ", result);
        if (result != null) {
            elif_stmt_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _elif_stmt() {
        // elif_stmt: 'elif' named_expression ':' block elif_stmt | 'elif' named_expression ':' block else_block?
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T[] b;
            T c;
            if (
                    this.expectKeyword("elif") != null
                            &&
                            (a = this.named_expression()) != null
                            &&
                            (literal = this.expectStr(':')) != null
                            &&
                            (b = this.block()) != null
                            &&
                            (c = this.elif_stmt()) != null
            ) {
                return ast.If ( a , b , ast.singleton_seq ( c ) , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            Token literal;
            T[] b;
            T[] c;
            if (
                    this.expectKeyword("elif") != null
                            &&
                            (a = this.named_expression()) != null
                            &&
                            (literal = this.expectStr(':')) != null
                            &&
                            (b = this.block()) != null
                            &&
                            ((c = this.else_block()) != null || true)
            ) {
                return ast.If ( a , b , c , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> else_block_cache = new HashMap<>();

    protected T[] else_block() {
        int p = this.mark();
        Memo<T[]> info = else_block_cache.get(p);
        if (info != null) {
            log("else_block() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("else_block() ...");
        this._level += 1;
        T[] result = _else_block();
        this._level -= 1;
        log("else_block() [fresh]-> ", result);
        if (result != null) {
            else_block_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _else_block() {
        // else_block: 'else' ':' block
        // type: asdl_stmt_seq*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T[] b;
            if (
                    this.expectKeyword("else") != null
                            &&
                            (literal = this.expectStr(':')) != null
                            &&
                            (b = this.block()) != null
            ) {
                return b;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> while_stmt_cache = new HashMap<>();

    protected T while_stmt() {
        int p = this.mark();
        Memo<T> info = while_stmt_cache.get(p);
        if (info != null) {
            log("while_stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("while_stmt() ...");
        this._level += 1;
        T result = _while_stmt();
        this._level -= 1;
        log("while_stmt() [fresh]-> ", result);
        if (result != null) {
            while_stmt_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _while_stmt() {
        // while_stmt: 'while' named_expression ':' block else_block?
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T[] b;
            T[] c;
            if (
                    this.expectKeyword("while") != null
                            &&
                            (a = this.named_expression()) != null
                            &&
                            (literal = this.expectStr(':')) != null
                            &&
                            (b = this.block()) != null
                            &&
                            ((c = this.else_block()) != null || true)
            ) {
                return ast.While ( a , b , c , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> for_stmt_cache = new HashMap<>();

    protected T for_stmt() {
        int p = this.mark();
        Memo<T> info = for_stmt_cache.get(p);
        if (info != null) {
            log("for_stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("for_stmt() ...");
        this._level += 1;
        T result = _for_stmt();
        this._level -= 1;
        log("for_stmt() [fresh]-> ", result);
        if (result != null) {
            for_stmt_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _for_stmt() {
        // for_stmt: 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block? | ASYNC 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T t;
            T ex;
            Token literal;
            Token tc;
            T[] b;
            T[] el;
            if (
                    this.expectKeyword("for") != null
                            &&
                            (t = this.star_targets()) != null
                            &&
                            this.expectKeyword("in") != null
                            &&
                            (cut = true)
                            &&
                            (ex = this.star_expressions()) != null
                            &&
                            (literal = this.expectStr(':')) != null
                            &&
                            ((tc = this.expect(TokenType.TYPE_COMMENT)) != null || true)
                            &&
                            (b = this.block()) != null
                            &&
                            ((el = this.else_block()) != null || true)
            ) {
                return ast.For ( t , ex , b , el , ast.type_comment ( tc ) , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T t;
            T ex;
            Token literal;
            Token tc;
            T[] b;
            T[] el;
            if (
                    this.expect(TokenType.ASYNC) != null
                            &&
                            this.expectKeyword("for") != null
                            &&
                            (t = this.star_targets()) != null
                            &&
                            this.expectKeyword("in") != null
                            &&
                            (cut = true)
                            &&
                            (ex = this.star_expressions()) != null
                            &&
                            (literal = this.expectStr(':')) != null
                            &&
                            ((tc = this.expect(TokenType.TYPE_COMMENT)) != null || true)
                            &&
                            (b = this.block()) != null
                            &&
                            ((el = this.else_block()) != null || true)
            ) {
                return ast.AsyncFor ( t , ex , b , el , ast.type_comment ( tc ) , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> with_stmt_cache = new HashMap<>();

    protected T with_stmt() {
        int p = this.mark();
        Memo<T> info = with_stmt_cache.get(p);
        if (info != null) {
            log("with_stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("with_stmt() ...");
        this._level += 1;
        T result = _with_stmt();
        this._level -= 1;
        log("with_stmt() [fresh]-> ", result);
        if (result != null) {
            with_stmt_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _with_stmt() {
        // with_stmt: 'with' '(' ','.with_item+ ','? ')' ':' block | 'with' ','.with_item+ ':' TYPE_COMMENT? block | ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block | ASYNC 'with' ','.with_item+ ':' TYPE_COMMENT? block
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T[] a;
            Token literal_1;
            Token literal_2;
            Token literal_3;
            T[] b;
            if (
                    this.expectKeyword("with") != null
                            &&
                            (literal = this.expectStr('(')) != null
                            &&
                            (a = this._gather_39()) != null
                            &&
                            ((literal_1 = this.expectStr(',')) != null || true)
                            &&
                            (literal_2 = this.expectStr(')')) != null
                            &&
                            (literal_3 = this.expectStr(':')) != null
                            &&
                            (b = this.block()) != null
            ) {
                return ast.With ( a , b , null , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T[] a;
            Token literal;
            Token tc;
            T[] b;
            if (
                    this.expectKeyword("with") != null
                            &&
                            (a = this._gather_41()) != null
                            &&
                            (literal = this.expectStr(':')) != null
                            &&
                            ((tc = this.expect(TokenType.TYPE_COMMENT)) != null || true)
                            &&
                            (b = this.block()) != null
            ) {
                return ast.With ( a , b , ast.type_comment ( tc ) , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            Token literal;
            T[] a;
            Token literal_1;
            Token literal_2;
            Token literal_3;
            T[] b;
            if (
                    this.expect(TokenType.ASYNC) != null
                            &&
                            this.expectKeyword("with") != null
                            &&
                            (literal = this.expectStr('(')) != null
                            &&
                            (a = this._gather_43()) != null
                            &&
                            ((literal_1 = this.expectStr(',')) != null || true)
                            &&
                            (literal_2 = this.expectStr(')')) != null
                            &&
                            (literal_3 = this.expectStr(':')) != null
                            &&
                            (b = this.block()) != null
            ) {
                return ast.AsyncWith ( a , b , null , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T[] a;
            Token literal;
            Token tc;
            T[] b;
            if (
                    this.expect(TokenType.ASYNC) != null
                            &&
                            this.expectKeyword("with") != null
                            &&
                            (a = this._gather_45()) != null
                            &&
                            (literal = this.expectStr(':')) != null
                            &&
                            ((tc = this.expect(TokenType.TYPE_COMMENT)) != null || true)
                            &&
                            (b = this.block()) != null
            ) {
                return ast.AsyncWith ( a , b , ast.type_comment ( tc ) , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> with_item_cache = new HashMap<>();

    protected T with_item() {
        int p = this.mark();
        Memo<T> info = with_item_cache.get(p);
        if (info != null) {
            log("with_item() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("with_item() ...");
        this._level += 1;
        T result = _with_item();
        this._level -= 1;
        log("with_item() [fresh]-> ", result);
        if (result != null) {
            with_item_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _with_item() {
        // with_item: expression 'as' star_target &(',' | ')' | ':') | expression
        // type: withitem_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T e;
            T t;
            if (
                    (e = this.expression()) != null
                            &&
                            this.expectKeyword("as") != null
                            &&
                            (t = this.star_target()) != null
                            &&
                            this.positive_lookahead(this::_tmp_47)
            ) {
                return ast.withitem ( e , t );
            }
            this.reset(mark);
        }
        {
            T e;
            if (
                    (e = this.expression()) != null
            ) {
                return ast.withitem ( e , null );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> try_stmt_cache = new HashMap<>();

    protected T try_stmt() {
        int p = this.mark();
        Memo<T> info = try_stmt_cache.get(p);
        if (info != null) {
            log("try_stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("try_stmt() ...");
        this._level += 1;
        T result = _try_stmt();
        this._level -= 1;
        log("try_stmt() [fresh]-> ", result);
        if (result != null) {
            try_stmt_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _try_stmt() {
        // try_stmt: 'try' ':' block finally_block | 'try' ':' block except_block+ else_block? finally_block?
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T[] b;
            T[] f;
            if (
                    this.expectKeyword("try") != null
                            &&
                            (literal = this.expectStr(':')) != null
                            &&
                            (b = this.block()) != null
                            &&
                            (f = this.finally_block()) != null
            ) {
                return ast.Try ( b , null , null , f , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            Token literal;
            T[] b;
            T[] ex;
            T[] el;
            T[] f;
            if (
                    this.expectKeyword("try") != null
                            &&
                            (literal = this.expectStr(':')) != null
                            &&
                            (b = this.block()) != null
                            &&
                            (ex = null_if_empty(this._loop1_48())) != null
                            &&
                            ((el = this.else_block()) != null || true)
                            &&
                            ((f = this.finally_block()) != null || true)
            ) {
                return ast.Try ( b , ex , el , f , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> except_block_cache = new HashMap<>();

    protected T except_block() {
        int p = this.mark();
        Memo<T> info = except_block_cache.get(p);
        if (info != null) {
            log("except_block() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("except_block() ...");
        this._level += 1;
        T result = _except_block();
        this._level -= 1;
        log("except_block() [fresh]-> ", result);
        if (result != null) {
            except_block_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _except_block() {
        // except_block: 'except' expression ['as' NAME] ':' block | 'except' ':' block
        // type: excepthandler_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T e;
            T t;
            Token literal;
            T[] b;
            if (
                    this.expectKeyword("except") != null
                            &&
                            (e = this.expression()) != null
                            &&
                            ((t = this._tmp_49()) != null || true)
                            &&
                            (literal = this.expectStr(':')) != null
                            &&
                            (b = this.block()) != null
            ) {
                return ast.ExceptHandler ( e , (t != null) ? ast.get_expr_name(t) : null , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            Token literal;
            T[] b;
            if (
                    this.expectKeyword("except") != null
                            &&
                            (literal = this.expectStr(':')) != null
                            &&
                            (b = this.block()) != null
            ) {
                return ast.ExceptHandler ( null , null , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> finally_block_cache = new HashMap<>();

    protected T[] finally_block() {
        int p = this.mark();
        Memo<T[]> info = finally_block_cache.get(p);
        if (info != null) {
            log("finally_block() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("finally_block() ...");
        this._level += 1;
        T[] result = _finally_block();
        this._level -= 1;
        log("finally_block() [fresh]-> ", result);
        if (result != null) {
            finally_block_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _finally_block() {
        // finally_block: 'finally' ':' block
        // type: asdl_stmt_seq*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T[] a;
            if (
                    this.expectKeyword("finally") != null
                            &&
                            (literal = this.expectStr(':')) != null
                            &&
                            (a = this.block()) != null
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> return_stmt_cache = new HashMap<>();

    protected T return_stmt() {
        int p = this.mark();
        Memo<T> info = return_stmt_cache.get(p);
        if (info != null) {
            log("return_stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("return_stmt() ...");
        this._level += 1;
        T result = _return_stmt();
        this._level -= 1;
        log("return_stmt() [fresh]-> ", result);
        if (result != null) {
            return_stmt_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _return_stmt() {
        // return_stmt: 'return' star_expressions?
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            if (
                    this.expectKeyword("return") != null
                            &&
                            ((a = this.star_expressions()) != null || true)
            ) {
                return ast.Return ( a , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> raise_stmt_cache = new HashMap<>();

    protected T raise_stmt() {
        int p = this.mark();
        Memo<T> info = raise_stmt_cache.get(p);
        if (info != null) {
            log("raise_stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("raise_stmt() ...");
        this._level += 1;
        T result = _raise_stmt();
        this._level -= 1;
        log("raise_stmt() [fresh]-> ", result);
        if (result != null) {
            raise_stmt_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _raise_stmt() {
        // raise_stmt: 'raise' expression ['from' expression] | 'raise'
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            T b;
            if (
                    this.expectKeyword("raise") != null
                            &&
                            (a = this.expression()) != null
                            &&
                            ((b = this._tmp_50()) != null || true)
            ) {
                return ast.Raise ( a , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            if (
                    this.expectKeyword("raise") != null
            ) {
                return ast.Raise ( null , null , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> function_def_cache = new HashMap<>();

    protected T function_def() {
        int p = this.mark();
        Memo<T> info = function_def_cache.get(p);
        if (info != null) {
            log("function_def() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("function_def() ...");
        this._level += 1;
        T result = _function_def();
        this._level -= 1;
        log("function_def() [fresh]-> ", result);
        if (result != null) {
            function_def_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _function_def() {
        // function_def: decorators function_def_raw | function_def_raw
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] d;
            T f;
            if (
                    (d = this.decorators()) != null
                            &&
                            (f = this.function_def_raw()) != null
            ) {
                return ast.function_def_decorators ( d , f );
            }
            this.reset(mark);
        }
        {
            T function_def_raw;
            if (
                    (function_def_raw = this.function_def_raw()) != null
            ) {
                return function_def_raw;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> function_def_raw_cache = new HashMap<>();

    protected T function_def_raw() {
        int p = this.mark();
        Memo<T> info = function_def_raw_cache.get(p);
        if (info != null) {
            log("function_def_raw() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("function_def_raw() ...");
        this._level += 1;
        T result = _function_def_raw();
        this._level -= 1;
        log("function_def_raw() [fresh]-> ", result);
        if (result != null) {
            function_def_raw_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _function_def_raw() {
        // function_def_raw: 'def' NAME '(' params? ')' ['->' expression] ':' func_type_comment? block | ASYNC 'def' NAME '(' params? ')' ['->' expression] ':' func_type_comment? block
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T n;
            Token literal;
            T params;
            Token literal_1;
            T a;
            Token literal_2;
            T tc;
            T[] b;
            if (
                    this.expectKeyword("def") != null
                            &&
                            (n = this.name()) != null
                            &&
                            (literal = this.expectStr('(')) != null
                            &&
                            ((params = this.params()) != null || true)
                            &&
                            (literal_1 = this.expectStr(')')) != null
                            &&
                            ((a = this._tmp_51()) != null || true)
                            &&
                            (literal_2 = this.expectStr(':')) != null
                            &&
                            ((tc = this.func_type_comment()) != null || true)
                            &&
                            (b = this.block()) != null
            ) {
                return ast.FunctionDef ( ast.get_expr_name(n) , (params != null) ? params : ast.empty_arguments ( ) , b , null , a , ast.type_comment ( tc ) , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T n;
            Token literal;
            T params;
            Token literal_1;
            T a;
            Token literal_2;
            T tc;
            T[] b;
            if (
                    this.expect(TokenType.ASYNC) != null
                            &&
                            this.expectKeyword("def") != null
                            &&
                            (n = this.name()) != null
                            &&
                            (literal = this.expectStr('(')) != null
                            &&
                            ((params = this.params()) != null || true)
                            &&
                            (literal_1 = this.expectStr(')')) != null
                            &&
                            ((a = this._tmp_52()) != null || true)
                            &&
                            (literal_2 = this.expectStr(':')) != null
                            &&
                            ((tc = this.func_type_comment()) != null || true)
                            &&
                            (b = this.block()) != null
            ) {
                return ast.AsyncFunctionDef ( ast.get_expr_name(n) , (params != null) ? params : ast.empty_arguments ( ) , b , null , a , ast.type_comment ( tc ) , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> func_type_comment_cache = new HashMap<>();

    protected T func_type_comment() {
        int p = this.mark();
        Memo<T> info = func_type_comment_cache.get(p);
        if (info != null) {
            log("func_type_comment() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("func_type_comment() ...");
        this._level += 1;
        T result = _func_type_comment();
        this._level -= 1;
        log("func_type_comment() [fresh]-> ", result);
        if (result != null) {
            func_type_comment_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _func_type_comment() {
        // func_type_comment: NEWLINE TYPE_COMMENT &(NEWLINE INDENT) | TYPE_COMMENT
        // type: Token*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token t;
            if (
                    this.expect(TokenType.NEWLINE) != null
                            &&
                            (t = this.expect(TokenType.TYPE_COMMENT)) != null
                            &&
                            this.positive_lookahead(this::_tmp_53)
            ) {
                return ast.from_token(t);
            }
            this.reset(mark);
        }
        {
            if (
                    this.expect(TokenType.TYPE_COMMENT) != null
            ) {
                return ast.None();
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> params_cache = new HashMap<>();

    protected T params() {
        int p = this.mark();
        Memo<T> info = params_cache.get(p);
        if (info != null) {
            log("params() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("params() ...");
        this._level += 1;
        T result = _params();
        this._level -= 1;
        log("params() [fresh]-> ", result);
        if (result != null) {
            params_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _params() {
        // params: parameters
        // type: arguments_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T parameters;
            if (
                    (parameters = this.parameters()) != null
            ) {
                return parameters;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> parameters_cache = new HashMap<>();

    protected T parameters() {
        int p = this.mark();
        Memo<T> info = parameters_cache.get(p);
        if (info != null) {
            log("parameters() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("parameters() ...");
        this._level += 1;
        T result = _parameters();
        this._level -= 1;
        log("parameters() [fresh]-> ", result);
        if (result != null) {
            parameters_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _parameters() {
        // parameters: slash_no_default param_no_default* param_with_default* star_etc? | slash_with_default param_with_default* star_etc? | param_no_default+ param_with_default* star_etc? | param_with_default+ star_etc? | star_etc
        // type: arguments_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            T[] b;
            T[] c;
            T d;
            if (
                    (a = this.slash_no_default()) != null
                            &&
                            (b = this._loop0_54()) != null
                            &&
                            (c = this._loop0_55()) != null
                            &&
                            ((d = this.star_etc()) != null || true)
            ) {
                return ast.make_arguments ( a , null , b , c , d );
            }
            this.reset(mark);
        }
        {
            T a;
            T[] b;
            T c;
            if (
                    (a = this.slash_with_default()) != null
                            &&
                            (b = this._loop0_56()) != null
                            &&
                            ((c = this.star_etc()) != null || true)
            ) {
                return ast.make_arguments ( null , a , null , b , c );
            }
            this.reset(mark);
        }
        {
            T[] a;
            T[] b;
            T c;
            if (
                    (a = null_if_empty(this._loop1_57())) != null
                            &&
                            (b = this._loop0_58()) != null
                            &&
                            ((c = this.star_etc()) != null || true)
            ) {
                return ast.make_arguments ( null , null , a , b , c );
            }
            this.reset(mark);
        }
        {
            T[] a;
            T b;
            if (
                    (a = null_if_empty(this._loop1_59())) != null
                            &&
                            ((b = this.star_etc()) != null || true)
            ) {
                return ast.make_arguments ( null , null , null , a , b );
            }
            this.reset(mark);
        }
        {
            T a;
            if (
                    (a = this.star_etc()) != null
            ) {
                return ast.make_arguments ( null , null , null , null , a );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> slash_no_default_cache = new HashMap<>();

    protected T[] slash_no_default() {
        int p = this.mark();
        Memo<T[]> info = slash_no_default_cache.get(p);
        if (info != null) {
            log("slash_no_default() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("slash_no_default() ...");
        this._level += 1;
        T[] result = _slash_no_default();
        this._level -= 1;
        log("slash_no_default() [fresh]-> ", result);
        if (result != null) {
            slash_no_default_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _slash_no_default() {
        // slash_no_default: param_no_default+ '/' ',' | param_no_default+ '/' &')'
        // type: asdl_arg_seq*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            Token literal;
            Token literal_1;
            if (
                    (a = null_if_empty(this._loop1_60())) != null
                            &&
                            (literal = this.expectStr('/')) != null
                            &&
                            (literal_1 = this.expectStr(',')) != null
            ) {
                return a;
            }
            this.reset(mark);
        }
        {
            T[] a;
            Token literal;
            if (
                    (a = null_if_empty(this._loop1_61())) != null
                            &&
                            (literal = this.expectStr('/')) != null
                            &&
                            this.positive_lookahead(this::expectStr, ')')
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> slash_with_default_cache = new HashMap<>();

    protected T slash_with_default() {
        int p = this.mark();
        Memo<T> info = slash_with_default_cache.get(p);
        if (info != null) {
            log("slash_with_default() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("slash_with_default() ...");
        this._level += 1;
        T result = _slash_with_default();
        this._level -= 1;
        log("slash_with_default() [fresh]-> ", result);
        if (result != null) {
            slash_with_default_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _slash_with_default() {
        // slash_with_default: param_no_default* param_with_default+ '/' ',' | param_no_default* param_with_default+ '/' &')'
        // type: SlashWithDefault*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            T[] b;
            Token literal;
            Token literal_1;
            if (
                    (a = this._loop0_62()) != null
                            &&
                            (b = null_if_empty(this._loop1_63())) != null
                            &&
                            (literal = this.expectStr('/')) != null
                            &&
                            (literal_1 = this.expectStr(',')) != null
            ) {
                return ast.slash_with_default ( a , b );
            }
            this.reset(mark);
        }
        {
            T[] a;
            T[] b;
            Token literal;
            if (
                    (a = this._loop0_64()) != null
                            &&
                            (b = null_if_empty(this._loop1_65())) != null
                            &&
                            (literal = this.expectStr('/')) != null
                            &&
                            this.positive_lookahead(this::expectStr, ')')
            ) {
                return ast.slash_with_default ( a , b );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> star_etc_cache = new HashMap<>();

    protected T star_etc() {
        int p = this.mark();
        Memo<T> info = star_etc_cache.get(p);
        if (info != null) {
            log("star_etc() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("star_etc() ...");
        this._level += 1;
        T result = _star_etc();
        this._level -= 1;
        log("star_etc() [fresh]-> ", result);
        if (result != null) {
            star_etc_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _star_etc() {
        // star_etc: '*' param_no_default param_maybe_default* kwds? | '*' ',' param_maybe_default+ kwds? | kwds
        // type: StarEtc*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T a;
            T[] b;
            T c;
            if (
                    (literal = this.expectStr('*')) != null
                            &&
                            (a = this.param_no_default()) != null
                            &&
                            (b = this._loop0_66()) != null
                            &&
                            ((c = this.kwds()) != null || true)
            ) {
                return ast.star_etc ( a , b , c );
            }
            this.reset(mark);
        }
        {
            Token literal;
            Token literal_1;
            T[] b;
            T c;
            if (
                    (literal = this.expectStr('*')) != null
                            &&
                            (literal_1 = this.expectStr(',')) != null
                            &&
                            (b = null_if_empty(this._loop1_67())) != null
                            &&
                            ((c = this.kwds()) != null || true)
            ) {
                return ast.star_etc ( null , b , c );
            }
            this.reset(mark);
        }
        {
            T a;
            if (
                    (a = this.kwds()) != null
            ) {
                return ast.star_etc ( null , null , a );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> kwds_cache = new HashMap<>();

    protected T kwds() {
        int p = this.mark();
        Memo<T> info = kwds_cache.get(p);
        if (info != null) {
            log("kwds() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("kwds() ...");
        this._level += 1;
        T result = _kwds();
        this._level -= 1;
        log("kwds() [fresh]-> ", result);
        if (result != null) {
            kwds_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _kwds() {
        // kwds: '**' param_no_default
        // type: arg_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T a;
            if (
                    (literal = this.expectStr("**")) != null
                            &&
                            (a = this.param_no_default()) != null
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> param_no_default_cache = new HashMap<>();

    protected T param_no_default() {
        int p = this.mark();
        Memo<T> info = param_no_default_cache.get(p);
        if (info != null) {
            log("param_no_default() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("param_no_default() ...");
        this._level += 1;
        T result = _param_no_default();
        this._level -= 1;
        log("param_no_default() [fresh]-> ", result);
        if (result != null) {
            param_no_default_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _param_no_default() {
        // param_no_default: param ',' TYPE_COMMENT? | param TYPE_COMMENT? &')'
        // type: arg_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            Token tc;
            if (
                    (a = this.param()) != null
                            &&
                            (literal = this.expectStr(',')) != null
                            &&
                            ((tc = this.expect(TokenType.TYPE_COMMENT)) != null || true)
            ) {
                return ast.add_type_comment_to_arg ( a , tc );
            }
            this.reset(mark);
        }
        {
            T a;
            Token tc;
            if (
                    (a = this.param()) != null
                            &&
                            ((tc = this.expect(TokenType.TYPE_COMMENT)) != null || true)
                            &&
                            this.positive_lookahead(this::expectStr, ')')
            ) {
                return ast.add_type_comment_to_arg ( a , tc );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> param_with_default_cache = new HashMap<>();

    protected T param_with_default() {
        int p = this.mark();
        Memo<T> info = param_with_default_cache.get(p);
        if (info != null) {
            log("param_with_default() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("param_with_default() ...");
        this._level += 1;
        T result = _param_with_default();
        this._level -= 1;
        log("param_with_default() [fresh]-> ", result);
        if (result != null) {
            param_with_default_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _param_with_default() {
        // param_with_default: param default ',' TYPE_COMMENT? | param default TYPE_COMMENT? &')'
        // type: NameDefaultPair*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            T c;
            Token literal;
            Token tc;
            if (
                    (a = this.param()) != null
                            &&
                            (c = this.default_()) != null
                            &&
                            (literal = this.expectStr(',')) != null
                            &&
                            ((tc = this.expect(TokenType.TYPE_COMMENT)) != null || true)
            ) {
                return ast.name_default_pair ( a , c , tc );
            }
            this.reset(mark);
        }
        {
            T a;
            T c;
            Token tc;
            if (
                    (a = this.param()) != null
                            &&
                            (c = this.default_()) != null
                            &&
                            ((tc = this.expect(TokenType.TYPE_COMMENT)) != null || true)
                            &&
                            this.positive_lookahead(this::expectStr, ')')
            ) {
                return ast.name_default_pair ( a , c , tc );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> param_maybe_default_cache = new HashMap<>();

    protected T param_maybe_default() {
        int p = this.mark();
        Memo<T> info = param_maybe_default_cache.get(p);
        if (info != null) {
            log("param_maybe_default() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("param_maybe_default() ...");
        this._level += 1;
        T result = _param_maybe_default();
        this._level -= 1;
        log("param_maybe_default() [fresh]-> ", result);
        if (result != null) {
            param_maybe_default_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _param_maybe_default() {
        // param_maybe_default: param default? ',' TYPE_COMMENT? | param default? TYPE_COMMENT? &')'
        // type: NameDefaultPair*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            T c;
            Token literal;
            Token tc;
            if (
                    (a = this.param()) != null
                            &&
                            ((c = this.default_()) != null || true)
                            &&
                            (literal = this.expectStr(',')) != null
                            &&
                            ((tc = this.expect(TokenType.TYPE_COMMENT)) != null || true)
            ) {
                return ast.name_default_pair ( a , c , tc );
            }
            this.reset(mark);
        }
        {
            T a;
            T c;
            Token tc;
            if (
                    (a = this.param()) != null
                            &&
                            ((c = this.default_()) != null || true)
                            &&
                            ((tc = this.expect(TokenType.TYPE_COMMENT)) != null || true)
                            &&
                            this.positive_lookahead(this::expectStr, ')')
            ) {
                return ast.name_default_pair ( a , c , tc );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> param_cache = new HashMap<>();

    protected T param() {
        int p = this.mark();
        Memo<T> info = param_cache.get(p);
        if (info != null) {
            log("param() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("param() ...");
        this._level += 1;
        T result = _param();
        this._level -= 1;
        log("param() [fresh]-> ", result);
        if (result != null) {
            param_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _param() {
        // param: NAME annotation?
        // type: arg_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            T b;
            if (
                    (a = this.name()) != null
                            &&
                            ((b = this.annotation()) != null || true)
            ) {
                return ast.arg ( ast.get_expr_name(a) , b , null , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> annotation_cache = new HashMap<>();

    protected T annotation() {
        int p = this.mark();
        Memo<T> info = annotation_cache.get(p);
        if (info != null) {
            log("annotation() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("annotation() ...");
        this._level += 1;
        T result = _annotation();
        this._level -= 1;
        log("annotation() [fresh]-> ", result);
        if (result != null) {
            annotation_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _annotation() {
        // annotation: ':' expression
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T a;
            if (
                    (literal = this.expectStr(':')) != null
                            &&
                            (a = this.expression()) != null
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> default_cache = new HashMap<>();

    protected T default_() {
        int p = this.mark();
        Memo<T> info = default_cache.get(p);
        if (info != null) {
            log("default() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("default() ...");
        this._level += 1;
        T result = _default_();
        this._level -= 1;
        log("default() [fresh]-> ", result);
        if (result != null) {
            default_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _default_() {
        // default: '=' expression
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T a;
            if (
                    (literal = this.expectStr('=')) != null
                            &&
                            (a = this.expression()) != null
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> decorators_cache = new HashMap<>();

    protected T[] decorators() {
        int p = this.mark();
        Memo<T[]> info = decorators_cache.get(p);
        if (info != null) {
            log("decorators() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("decorators() ...");
        this._level += 1;
        T[] result = _decorators();
        this._level -= 1;
        log("decorators() [fresh]-> ", result);
        if (result != null) {
            decorators_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _decorators() {
        // decorators: (('@' named_expression NEWLINE))+
        // type: asdl_expr_seq*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            if (
                    (a = null_if_empty(this._loop1_68())) != null
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> class_def_cache = new HashMap<>();

    protected T class_def() {
        int p = this.mark();
        Memo<T> info = class_def_cache.get(p);
        if (info != null) {
            log("class_def() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("class_def() ...");
        this._level += 1;
        T result = _class_def();
        this._level -= 1;
        log("class_def() [fresh]-> ", result);
        if (result != null) {
            class_def_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _class_def() {
        // class_def: decorators class_def_raw | class_def_raw
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            T b;
            if (
                    (a = this.decorators()) != null
                            &&
                            (b = this.class_def_raw()) != null
            ) {
                return ast.class_def_decorators ( a , b );
            }
            this.reset(mark);
        }
        {
            T class_def_raw;
            if (
                    (class_def_raw = this.class_def_raw()) != null
            ) {
                return class_def_raw;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> class_def_raw_cache = new HashMap<>();

    protected T class_def_raw() {
        int p = this.mark();
        Memo<T> info = class_def_raw_cache.get(p);
        if (info != null) {
            log("class_def_raw() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("class_def_raw() ...");
        this._level += 1;
        T result = _class_def_raw();
        this._level -= 1;
        log("class_def_raw() [fresh]-> ", result);
        if (result != null) {
            class_def_raw_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _class_def_raw() {
        // class_def_raw: 'class' NAME ['(' arguments? ')'] ':' block
        // type: stmt_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            T b;
            Token literal;
            T[] c;
            if (
                    this.expectKeyword("class") != null
                            &&
                            (a = this.name()) != null
                            &&
                            ((b = this._tmp_69()) != null || true)
                            &&
                            (literal = this.expectStr(':')) != null
                            &&
                            (c = this.block()) != null
            ) {
                return ast.ClassDef ( ast.get_expr_name(a) , (b != null) ? ast.get_call_args(b) : null , (b != null) ? ast.get_call_keywords(b) : null , c , null , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> block_cache = new HashMap<>();

    protected T[] block() {
        int p = this.mark();
        Memo<T[]> info = block_cache.get(p);
        if (info != null) {
            log("block() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("block() ...");
        this._level += 1;
        T[] result = _block();
        this._level -= 1;
        log("block() [fresh]-> ", result);
        if (result != null) {
            block_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _block() {
        // block: NEWLINE INDENT statements DEDENT | simple_stmt
        // type: asdl_stmt_seq*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            if (
                    this.expect(TokenType.NEWLINE) != null
                            &&
                            this.expect(TokenType.INDENT) != null
                            &&
                            (a = this.statements()) != null
                            &&
                            this.expect(TokenType.DEDENT) != null
            ) {
                return a;
            }
            this.reset(mark);
        }
        {
            T[] simple_stmt;
            if (
                    (simple_stmt = this.simple_stmt()) != null
            ) {
                return simple_stmt;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> expressions_list_cache = new HashMap<>();

    protected T[] expressions_list() {
        int p = this.mark();
        Memo<T[]> info = expressions_list_cache.get(p);
        if (info != null) {
            log("expressions_list() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("expressions_list() ...");
        this._level += 1;
        T[] result = _expressions_list();
        this._level -= 1;
        log("expressions_list() [fresh]-> ", result);
        if (result != null) {
            expressions_list_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _expressions_list() {
        // expressions_list: ','.star_expression+ ','?
        // type: asdl_expr_seq*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            Token literal;
            if (
                    (a = this._gather_70()) != null
                            &&
                            ((literal = this.expectStr(',')) != null || true)
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> star_expressions_cache = new HashMap<>();

    protected T star_expressions() {
        int p = this.mark();
        Memo<T> info = star_expressions_cache.get(p);
        if (info != null) {
            log("star_expressions() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("star_expressions() ...");
        this._level += 1;
        T result = _star_expressions();
        this._level -= 1;
        log("star_expressions() [fresh]-> ", result);
        if (result != null) {
            star_expressions_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _star_expressions() {
        // star_expressions: star_expression ((',' star_expression))+ ','? | star_expression ',' | star_expression
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            T[] b;
            Token literal;
            if (
                    (a = this.star_expression()) != null
                            &&
                            (b = null_if_empty(this._loop1_72())) != null
                            &&
                            ((literal = this.expectStr(',')) != null || true)
            ) {
                return ast.Tuple ( ast.seq_insert_in_front ( a , b ) , ast.Load() , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            Token literal;
            if (
                    (a = this.star_expression()) != null
                            &&
                            (literal = this.expectStr(',')) != null
            ) {
                return ast.Tuple ( ast.singleton_seq ( a ) , ast.Load() , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T star_expression;
            if (
                    (star_expression = this.star_expression()) != null
            ) {
                return star_expression;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> star_expression_cache = new HashMap<>();

    protected T star_expression() {
        int p = this.mark();
        Memo<T> info = star_expression_cache.get(p);
        if (info != null) {
            log("star_expression() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("star_expression() ...");
        this._level += 1;
        T result = _star_expression();
        this._level -= 1;
        log("star_expression() [fresh]-> ", result);
        if (result != null) {
            star_expression_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _star_expression() {
        // star_expression: '*' bitwise_or | expression
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T a;
            if (
                    (literal = this.expectStr('*')) != null
                            &&
                            (a = this.bitwise_or()) != null
            ) {
                return ast.Starred ( a , ast.Load() , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T expression;
            if (
                    (expression = this.expression()) != null
            ) {
                return expression;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> star_named_expressions_cache = new HashMap<>();

    protected T[] star_named_expressions() {
        int p = this.mark();
        Memo<T[]> info = star_named_expressions_cache.get(p);
        if (info != null) {
            log("star_named_expressions() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("star_named_expressions() ...");
        this._level += 1;
        T[] result = _star_named_expressions();
        this._level -= 1;
        log("star_named_expressions() [fresh]-> ", result);
        if (result != null) {
            star_named_expressions_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _star_named_expressions() {
        // star_named_expressions: ','.star_named_expression+ ','?
        // type: asdl_expr_seq*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            Token literal;
            if (
                    (a = this._gather_73()) != null
                            &&
                            ((literal = this.expectStr(',')) != null || true)
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> star_named_expression_cache = new HashMap<>();

    protected T star_named_expression() {
        int p = this.mark();
        Memo<T> info = star_named_expression_cache.get(p);
        if (info != null) {
            log("star_named_expression() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("star_named_expression() ...");
        this._level += 1;
        T result = _star_named_expression();
        this._level -= 1;
        log("star_named_expression() [fresh]-> ", result);
        if (result != null) {
            star_named_expression_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _star_named_expression() {
        // star_named_expression: '*' bitwise_or | named_expression
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T a;
            if (
                    (literal = this.expectStr('*')) != null
                            &&
                            (a = this.bitwise_or()) != null
            ) {
                return ast.Starred ( a , ast.Load() , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T named_expression;
            if (
                    (named_expression = this.named_expression()) != null
            ) {
                return named_expression;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> named_expression_cache = new HashMap<>();

    protected T named_expression() {
        int p = this.mark();
        Memo<T> info = named_expression_cache.get(p);
        if (info != null) {
            log("named_expression() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("named_expression() ...");
        this._level += 1;
        T result = _named_expression();
        this._level -= 1;
        log("named_expression() [fresh]-> ", result);
        if (result != null) {
            named_expression_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _named_expression() {
        // named_expression: NAME ':=' ~ expression | expression !':='
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.name()) != null
                            &&
                            (literal = this.expectStr(":=")) != null
                            &&
                            (cut = true)
                            &&
                            (b = this.expression()) != null
            ) {
                return ast.NamedExpr ( ast.set_expr_context ( a , ast.Store() ) , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T expression;
            if (
                    (expression = this.expression()) != null
                            &&
                            this.negative_lookahead(this::expectStr, ":=")
            ) {
                return expression;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> annotated_rhs_cache = new HashMap<>();

    protected T annotated_rhs() {
        int p = this.mark();
        Memo<T> info = annotated_rhs_cache.get(p);
        if (info != null) {
            log("annotated_rhs() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("annotated_rhs() ...");
        this._level += 1;
        T result = _annotated_rhs();
        this._level -= 1;
        log("annotated_rhs() [fresh]-> ", result);
        if (result != null) {
            annotated_rhs_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _annotated_rhs() {
        // annotated_rhs: yield_expr | star_expressions
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T yield_expr;
            if (
                    (yield_expr = this.yield_expr()) != null
            ) {
                return yield_expr;
            }
            this.reset(mark);
        }
        {
            T star_expressions;
            if (
                    (star_expressions = this.star_expressions()) != null
            ) {
                return star_expressions;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> expressions_cache = new HashMap<>();

    protected T expressions() {
        int p = this.mark();
        Memo<T> info = expressions_cache.get(p);
        if (info != null) {
            log("expressions() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("expressions() ...");
        this._level += 1;
        T result = _expressions();
        this._level -= 1;
        log("expressions() [fresh]-> ", result);
        if (result != null) {
            expressions_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _expressions() {
        // expressions: expression ((',' expression))+ ','? | expression ',' | expression
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            T[] b;
            Token literal;
            if (
                    (a = this.expression()) != null
                            &&
                            (b = null_if_empty(this._loop1_75())) != null
                            &&
                            ((literal = this.expectStr(',')) != null || true)
            ) {
                return ast.Tuple ( ast.seq_insert_in_front ( a , b ) , ast.Load() , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            Token literal;
            if (
                    (a = this.expression()) != null
                            &&
                            (literal = this.expectStr(',')) != null
            ) {
                return ast.Tuple ( ast.singleton_seq ( a ) , ast.Load() , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T expression;
            if (
                    (expression = this.expression()) != null
            ) {
                return expression;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> expression_cache = new HashMap<>();

    protected T expression() {
        int p = this.mark();
        Memo<T> info = expression_cache.get(p);
        if (info != null) {
            log("expression() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("expression() ...");
        this._level += 1;
        T result = _expression();
        this._level -= 1;
        log("expression() [fresh]-> ", result);
        if (result != null) {
            expression_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _expression() {
        // expression: disjunction 'if' disjunction 'else' expression | disjunction | lambdef
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            T b;
            T c;
            if (
                    (a = this.disjunction()) != null
                            &&
                            this.expectKeyword("if") != null
                            &&
                            (b = this.disjunction()) != null
                            &&
                            this.expectKeyword("else") != null
                            &&
                            (c = this.expression()) != null
            ) {
                return ast.IfExp ( b , a , c , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T disjunction;
            if (
                    (disjunction = this.disjunction()) != null
            ) {
                return disjunction;
            }
            this.reset(mark);
        }
        {
            T lambdef;
            if (
                    (lambdef = this.lambdef()) != null
            ) {
                return lambdef;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> lambdef_cache = new HashMap<>();

    protected T lambdef() {
        int p = this.mark();
        Memo<T> info = lambdef_cache.get(p);
        if (info != null) {
            log("lambdef() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("lambdef() ...");
        this._level += 1;
        T result = _lambdef();
        this._level -= 1;
        log("lambdef() [fresh]-> ", result);
        if (result != null) {
            lambdef_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _lambdef() {
        // lambdef: 'lambda' lambda_params? ':' expression
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T b;
            if (
                    this.expectKeyword("lambda") != null
                            &&
                            ((a = this.lambda_params()) != null || true)
                            &&
                            (literal = this.expectStr(':')) != null
                            &&
                            (b = this.expression()) != null
            ) {
                return ast.Lambda ( (a != null) ? a : ast.empty_arguments ( ) , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> lambda_params_cache = new HashMap<>();

    protected T lambda_params() {
        int p = this.mark();
        Memo<T> info = lambda_params_cache.get(p);
        if (info != null) {
            log("lambda_params() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("lambda_params() ...");
        this._level += 1;
        T result = _lambda_params();
        this._level -= 1;
        log("lambda_params() [fresh]-> ", result);
        if (result != null) {
            lambda_params_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _lambda_params() {
        // lambda_params: lambda_parameters
        // type: arguments_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T lambda_parameters;
            if (
                    (lambda_parameters = this.lambda_parameters()) != null
            ) {
                return lambda_parameters;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> lambda_parameters_cache = new HashMap<>();

    protected T lambda_parameters() {
        int p = this.mark();
        Memo<T> info = lambda_parameters_cache.get(p);
        if (info != null) {
            log("lambda_parameters() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("lambda_parameters() ...");
        this._level += 1;
        T result = _lambda_parameters();
        this._level -= 1;
        log("lambda_parameters() [fresh]-> ", result);
        if (result != null) {
            lambda_parameters_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _lambda_parameters() {
        // lambda_parameters: lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc? | lambda_slash_with_default lambda_param_with_default* lambda_star_etc? | lambda_param_no_default+ lambda_param_with_default* lambda_star_etc? | lambda_param_with_default+ lambda_star_etc? | lambda_star_etc
        // type: arguments_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            T[] b;
            T[] c;
            T d;
            if (
                    (a = this.lambda_slash_no_default()) != null
                            &&
                            (b = this._loop0_76()) != null
                            &&
                            (c = this._loop0_77()) != null
                            &&
                            ((d = this.lambda_star_etc()) != null || true)
            ) {
                return ast.make_arguments ( a , null , b , c , d );
            }
            this.reset(mark);
        }
        {
            T a;
            T[] b;
            T c;
            if (
                    (a = this.lambda_slash_with_default()) != null
                            &&
                            (b = this._loop0_78()) != null
                            &&
                            ((c = this.lambda_star_etc()) != null || true)
            ) {
                return ast.make_arguments ( null , a , null , b , c );
            }
            this.reset(mark);
        }
        {
            T[] a;
            T[] b;
            T c;
            if (
                    (a = null_if_empty(this._loop1_79())) != null
                            &&
                            (b = this._loop0_80()) != null
                            &&
                            ((c = this.lambda_star_etc()) != null || true)
            ) {
                return ast.make_arguments ( null , null , a , b , c );
            }
            this.reset(mark);
        }
        {
            T[] a;
            T b;
            if (
                    (a = null_if_empty(this._loop1_81())) != null
                            &&
                            ((b = this.lambda_star_etc()) != null || true)
            ) {
                return ast.make_arguments ( null , null , null , a , b );
            }
            this.reset(mark);
        }
        {
            T a;
            if (
                    (a = this.lambda_star_etc()) != null
            ) {
                return ast.make_arguments ( null , null , null , null , a );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> lambda_slash_no_default_cache = new HashMap<>();

    protected T[] lambda_slash_no_default() {
        int p = this.mark();
        Memo<T[]> info = lambda_slash_no_default_cache.get(p);
        if (info != null) {
            log("lambda_slash_no_default() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("lambda_slash_no_default() ...");
        this._level += 1;
        T[] result = _lambda_slash_no_default();
        this._level -= 1;
        log("lambda_slash_no_default() [fresh]-> ", result);
        if (result != null) {
            lambda_slash_no_default_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _lambda_slash_no_default() {
        // lambda_slash_no_default: lambda_param_no_default+ '/' ',' | lambda_param_no_default+ '/' &':'
        // type: asdl_arg_seq*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            Token literal;
            Token literal_1;
            if (
                    (a = null_if_empty(this._loop1_82())) != null
                            &&
                            (literal = this.expectStr('/')) != null
                            &&
                            (literal_1 = this.expectStr(',')) != null
            ) {
                return a;
            }
            this.reset(mark);
        }
        {
            T[] a;
            Token literal;
            if (
                    (a = null_if_empty(this._loop1_83())) != null
                            &&
                            (literal = this.expectStr('/')) != null
                            &&
                            this.positive_lookahead(this::expectStr, ':')
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> lambda_slash_with_default_cache = new HashMap<>();

    protected T lambda_slash_with_default() {
        int p = this.mark();
        Memo<T> info = lambda_slash_with_default_cache.get(p);
        if (info != null) {
            log("lambda_slash_with_default() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("lambda_slash_with_default() ...");
        this._level += 1;
        T result = _lambda_slash_with_default();
        this._level -= 1;
        log("lambda_slash_with_default() [fresh]-> ", result);
        if (result != null) {
            lambda_slash_with_default_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _lambda_slash_with_default() {
        // lambda_slash_with_default: lambda_param_no_default* lambda_param_with_default+ '/' ',' | lambda_param_no_default* lambda_param_with_default+ '/' &':'
        // type: SlashWithDefault*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            T[] b;
            Token literal;
            Token literal_1;
            if (
                    (a = this._loop0_84()) != null
                            &&
                            (b = null_if_empty(this._loop1_85())) != null
                            &&
                            (literal = this.expectStr('/')) != null
                            &&
                            (literal_1 = this.expectStr(',')) != null
            ) {
                return ast.slash_with_default ( a , b );
            }
            this.reset(mark);
        }
        {
            T[] a;
            T[] b;
            Token literal;
            if (
                    (a = this._loop0_86()) != null
                            &&
                            (b = null_if_empty(this._loop1_87())) != null
                            &&
                            (literal = this.expectStr('/')) != null
                            &&
                            this.positive_lookahead(this::expectStr, ':')
            ) {
                return ast.slash_with_default ( a , b );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> lambda_star_etc_cache = new HashMap<>();

    protected T lambda_star_etc() {
        int p = this.mark();
        Memo<T> info = lambda_star_etc_cache.get(p);
        if (info != null) {
            log("lambda_star_etc() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("lambda_star_etc() ...");
        this._level += 1;
        T result = _lambda_star_etc();
        this._level -= 1;
        log("lambda_star_etc() [fresh]-> ", result);
        if (result != null) {
            lambda_star_etc_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _lambda_star_etc() {
        // lambda_star_etc: '*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds? | '*' ',' lambda_param_maybe_default+ lambda_kwds? | lambda_kwds
        // type: StarEtc*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T a;
            T[] b;
            T c;
            if (
                    (literal = this.expectStr('*')) != null
                            &&
                            (a = this.lambda_param_no_default()) != null
                            &&
                            (b = this._loop0_88()) != null
                            &&
                            ((c = this.lambda_kwds()) != null || true)
            ) {
                return ast.star_etc ( a , b , c );
            }
            this.reset(mark);
        }
        {
            Token literal;
            Token literal_1;
            T[] b;
            T c;
            if (
                    (literal = this.expectStr('*')) != null
                            &&
                            (literal_1 = this.expectStr(',')) != null
                            &&
                            (b = null_if_empty(this._loop1_89())) != null
                            &&
                            ((c = this.lambda_kwds()) != null || true)
            ) {
                return ast.star_etc ( null , b , c );
            }
            this.reset(mark);
        }
        {
            T a;
            if (
                    (a = this.lambda_kwds()) != null
            ) {
                return ast.star_etc ( null , null , a );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> lambda_kwds_cache = new HashMap<>();

    protected T lambda_kwds() {
        int p = this.mark();
        Memo<T> info = lambda_kwds_cache.get(p);
        if (info != null) {
            log("lambda_kwds() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("lambda_kwds() ...");
        this._level += 1;
        T result = _lambda_kwds();
        this._level -= 1;
        log("lambda_kwds() [fresh]-> ", result);
        if (result != null) {
            lambda_kwds_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _lambda_kwds() {
        // lambda_kwds: '**' lambda_param_no_default
        // type: arg_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T a;
            if (
                    (literal = this.expectStr("**")) != null
                            &&
                            (a = this.lambda_param_no_default()) != null
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> lambda_param_no_default_cache = new HashMap<>();

    protected T lambda_param_no_default() {
        int p = this.mark();
        Memo<T> info = lambda_param_no_default_cache.get(p);
        if (info != null) {
            log("lambda_param_no_default() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("lambda_param_no_default() ...");
        this._level += 1;
        T result = _lambda_param_no_default();
        this._level -= 1;
        log("lambda_param_no_default() [fresh]-> ", result);
        if (result != null) {
            lambda_param_no_default_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _lambda_param_no_default() {
        // lambda_param_no_default: lambda_param ',' | lambda_param &':'
        // type: arg_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            if (
                    (a = this.lambda_param()) != null
                            &&
                            (literal = this.expectStr(',')) != null
            ) {
                return a;
            }
            this.reset(mark);
        }
        {
            T a;
            if (
                    (a = this.lambda_param()) != null
                            &&
                            this.positive_lookahead(this::expectStr, ':')
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> lambda_param_with_default_cache = new HashMap<>();

    protected T lambda_param_with_default() {
        int p = this.mark();
        Memo<T> info = lambda_param_with_default_cache.get(p);
        if (info != null) {
            log("lambda_param_with_default() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("lambda_param_with_default() ...");
        this._level += 1;
        T result = _lambda_param_with_default();
        this._level -= 1;
        log("lambda_param_with_default() [fresh]-> ", result);
        if (result != null) {
            lambda_param_with_default_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _lambda_param_with_default() {
        // lambda_param_with_default: lambda_param default ',' | lambda_param default &':'
        // type: NameDefaultPair*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            T c;
            Token literal;
            if (
                    (a = this.lambda_param()) != null
                            &&
                            (c = this.default_()) != null
                            &&
                            (literal = this.expectStr(',')) != null
            ) {
                return ast.name_default_pair ( a , c , null );
            }
            this.reset(mark);
        }
        {
            T a;
            T c;
            if (
                    (a = this.lambda_param()) != null
                            &&
                            (c = this.default_()) != null
                            &&
                            this.positive_lookahead(this::expectStr, ':')
            ) {
                return ast.name_default_pair ( a , c , null );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> lambda_param_maybe_default_cache = new HashMap<>();

    protected T lambda_param_maybe_default() {
        int p = this.mark();
        Memo<T> info = lambda_param_maybe_default_cache.get(p);
        if (info != null) {
            log("lambda_param_maybe_default() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("lambda_param_maybe_default() ...");
        this._level += 1;
        T result = _lambda_param_maybe_default();
        this._level -= 1;
        log("lambda_param_maybe_default() [fresh]-> ", result);
        if (result != null) {
            lambda_param_maybe_default_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _lambda_param_maybe_default() {
        // lambda_param_maybe_default: lambda_param default? ',' | lambda_param default? &':'
        // type: NameDefaultPair*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            T c;
            Token literal;
            if (
                    (a = this.lambda_param()) != null
                            &&
                            ((c = this.default_()) != null || true)
                            &&
                            (literal = this.expectStr(',')) != null
            ) {
                return ast.name_default_pair ( a , c , null );
            }
            this.reset(mark);
        }
        {
            T a;
            T c;
            if (
                    (a = this.lambda_param()) != null
                            &&
                            ((c = this.default_()) != null || true)
                            &&
                            this.positive_lookahead(this::expectStr, ':')
            ) {
                return ast.name_default_pair ( a , c , null );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> lambda_param_cache = new HashMap<>();

    protected T lambda_param() {
        int p = this.mark();
        Memo<T> info = lambda_param_cache.get(p);
        if (info != null) {
            log("lambda_param() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("lambda_param() ...");
        this._level += 1;
        T result = _lambda_param();
        this._level -= 1;
        log("lambda_param() [fresh]-> ", result);
        if (result != null) {
            lambda_param_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _lambda_param() {
        // lambda_param: NAME
        // type: arg_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            if (
                    (a = this.name()) != null
            ) {
                return ast.arg ( ast.get_expr_name(a) , null , null , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> disjunction_cache = new HashMap<>();

    protected T disjunction() {
        int p = this.mark();
        Memo<T> info = disjunction_cache.get(p);
        if (info != null) {
            log("disjunction() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("disjunction() ...");
        this._level += 1;
        T result = _disjunction();
        this._level -= 1;
        log("disjunction() [fresh]-> ", result);
        if (result != null) {
            disjunction_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _disjunction() {
        // disjunction: conjunction (('or' conjunction))+ | conjunction
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            T[] b;
            if (
                    (a = this.conjunction()) != null
                            &&
                            (b = null_if_empty(this._loop1_90())) != null
            ) {
                return ast.BoolOp ( ast.Or() , ast.seq_insert_in_front ( a , b ) , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T conjunction;
            if (
                    (conjunction = this.conjunction()) != null
            ) {
                return conjunction;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> conjunction_cache = new HashMap<>();

    protected T conjunction() {
        int p = this.mark();
        Memo<T> info = conjunction_cache.get(p);
        if (info != null) {
            log("conjunction() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("conjunction() ...");
        this._level += 1;
        T result = _conjunction();
        this._level -= 1;
        log("conjunction() [fresh]-> ", result);
        if (result != null) {
            conjunction_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _conjunction() {
        // conjunction: inversion (('and' inversion))+ | inversion
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            T[] b;
            if (
                    (a = this.inversion()) != null
                            &&
                            (b = null_if_empty(this._loop1_91())) != null
            ) {
                return ast.BoolOp ( ast.And() , ast.seq_insert_in_front ( a , b ) , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T inversion;
            if (
                    (inversion = this.inversion()) != null
            ) {
                return inversion;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> inversion_cache = new HashMap<>();

    protected T inversion() {
        int p = this.mark();
        Memo<T> info = inversion_cache.get(p);
        if (info != null) {
            log("inversion() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("inversion() ...");
        this._level += 1;
        T result = _inversion();
        this._level -= 1;
        log("inversion() [fresh]-> ", result);
        if (result != null) {
            inversion_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _inversion() {
        // inversion: 'not' inversion | comparison
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            if (
                    this.expectKeyword("not") != null
                            &&
                            (a = this.inversion()) != null
            ) {
                return ast.UnaryOp ( ast.Not() , a , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T comparison;
            if (
                    (comparison = this.comparison()) != null
            ) {
                return comparison;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> comparison_cache = new HashMap<>();

    protected T comparison() {
        int p = this.mark();
        Memo<T> info = comparison_cache.get(p);
        if (info != null) {
            log("comparison() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("comparison() ...");
        this._level += 1;
        T result = _comparison();
        this._level -= 1;
        log("comparison() [fresh]-> ", result);
        if (result != null) {
            comparison_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _comparison() {
        // comparison: bitwise_or compare_op_bitwise_or_pair+ | bitwise_or
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            T[] b;
            if (
                    (a = this.bitwise_or()) != null
                            &&
                            (b = null_if_empty(this._loop1_92())) != null
            ) {
                return ast.Compare ( a , ast.get_cmpops ( b ) , ast.get_exprs ( b ) , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T bitwise_or;
            if (
                    (bitwise_or = this.bitwise_or()) != null
            ) {
                return bitwise_or;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> compare_op_bitwise_or_pair_cache = new HashMap<>();

    protected T compare_op_bitwise_or_pair() {
        int p = this.mark();
        Memo<T> info = compare_op_bitwise_or_pair_cache.get(p);
        if (info != null) {
            log("compare_op_bitwise_or_pair() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("compare_op_bitwise_or_pair() ...");
        this._level += 1;
        T result = _compare_op_bitwise_or_pair();
        this._level -= 1;
        log("compare_op_bitwise_or_pair() [fresh]-> ", result);
        if (result != null) {
            compare_op_bitwise_or_pair_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _compare_op_bitwise_or_pair() {
        // compare_op_bitwise_or_pair: eq_bitwise_or | noteq_bitwise_or | lte_bitwise_or | lt_bitwise_or | gte_bitwise_or | gt_bitwise_or | notin_bitwise_or | in_bitwise_or | isnot_bitwise_or | is_bitwise_or
        // type: CmpopExprPair*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T eq_bitwise_or;
            if (
                    (eq_bitwise_or = this.eq_bitwise_or()) != null
            ) {
                return eq_bitwise_or;
            }
            this.reset(mark);
        }
        {
            T noteq_bitwise_or;
            if (
                    (noteq_bitwise_or = this.noteq_bitwise_or()) != null
            ) {
                return noteq_bitwise_or;
            }
            this.reset(mark);
        }
        {
            T lte_bitwise_or;
            if (
                    (lte_bitwise_or = this.lte_bitwise_or()) != null
            ) {
                return lte_bitwise_or;
            }
            this.reset(mark);
        }
        {
            T lt_bitwise_or;
            if (
                    (lt_bitwise_or = this.lt_bitwise_or()) != null
            ) {
                return lt_bitwise_or;
            }
            this.reset(mark);
        }
        {
            T gte_bitwise_or;
            if (
                    (gte_bitwise_or = this.gte_bitwise_or()) != null
            ) {
                return gte_bitwise_or;
            }
            this.reset(mark);
        }
        {
            T gt_bitwise_or;
            if (
                    (gt_bitwise_or = this.gt_bitwise_or()) != null
            ) {
                return gt_bitwise_or;
            }
            this.reset(mark);
        }
        {
            T notin_bitwise_or;
            if (
                    (notin_bitwise_or = this.notin_bitwise_or()) != null
            ) {
                return notin_bitwise_or;
            }
            this.reset(mark);
        }
        {
            T in_bitwise_or;
            if (
                    (in_bitwise_or = this.in_bitwise_or()) != null
            ) {
                return in_bitwise_or;
            }
            this.reset(mark);
        }
        {
            T isnot_bitwise_or;
            if (
                    (isnot_bitwise_or = this.isnot_bitwise_or()) != null
            ) {
                return isnot_bitwise_or;
            }
            this.reset(mark);
        }
        {
            T is_bitwise_or;
            if (
                    (is_bitwise_or = this.is_bitwise_or()) != null
            ) {
                return is_bitwise_or;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> eq_bitwise_or_cache = new HashMap<>();

    protected T eq_bitwise_or() {
        int p = this.mark();
        Memo<T> info = eq_bitwise_or_cache.get(p);
        if (info != null) {
            log("eq_bitwise_or() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("eq_bitwise_or() ...");
        this._level += 1;
        T result = _eq_bitwise_or();
        this._level -= 1;
        log("eq_bitwise_or() [fresh]-> ", result);
        if (result != null) {
            eq_bitwise_or_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _eq_bitwise_or() {
        // eq_bitwise_or: '==' bitwise_or
        // type: CmpopExprPair*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T a;
            if (
                    (literal = this.expectStr("==")) != null
                            &&
                            (a = this.bitwise_or()) != null
            ) {
                return ast.cmpop_expr_pair ( ast.Eq() , a );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> noteq_bitwise_or_cache = new HashMap<>();

    protected T noteq_bitwise_or() {
        int p = this.mark();
        Memo<T> info = noteq_bitwise_or_cache.get(p);
        if (info != null) {
            log("noteq_bitwise_or() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("noteq_bitwise_or() ...");
        this._level += 1;
        T result = _noteq_bitwise_or();
        this._level -= 1;
        log("noteq_bitwise_or() [fresh]-> ", result);
        if (result != null) {
            noteq_bitwise_or_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _noteq_bitwise_or() {
        // noteq_bitwise_or: ('!=') bitwise_or
        // type: CmpopExprPair*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token tok;
            T a;
            if (
                    (tok = this.expectStr("!=")) != null
                            &&
                            (a = this.bitwise_or()) != null
            ) {
                return ast.cmpop_expr_pair ( ast.NotEq() , a );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> lte_bitwise_or_cache = new HashMap<>();

    protected T lte_bitwise_or() {
        int p = this.mark();
        Memo<T> info = lte_bitwise_or_cache.get(p);
        if (info != null) {
            log("lte_bitwise_or() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("lte_bitwise_or() ...");
        this._level += 1;
        T result = _lte_bitwise_or();
        this._level -= 1;
        log("lte_bitwise_or() [fresh]-> ", result);
        if (result != null) {
            lte_bitwise_or_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _lte_bitwise_or() {
        // lte_bitwise_or: '<=' bitwise_or
        // type: CmpopExprPair*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T a;
            if (
                    (literal = this.expectStr("<=")) != null
                            &&
                            (a = this.bitwise_or()) != null
            ) {
                return ast.cmpop_expr_pair ( ast.LtE() , a );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> lt_bitwise_or_cache = new HashMap<>();

    protected T lt_bitwise_or() {
        int p = this.mark();
        Memo<T> info = lt_bitwise_or_cache.get(p);
        if (info != null) {
            log("lt_bitwise_or() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("lt_bitwise_or() ...");
        this._level += 1;
        T result = _lt_bitwise_or();
        this._level -= 1;
        log("lt_bitwise_or() [fresh]-> ", result);
        if (result != null) {
            lt_bitwise_or_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _lt_bitwise_or() {
        // lt_bitwise_or: '<' bitwise_or
        // type: CmpopExprPair*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T a;
            if (
                    (literal = this.expectStr('<')) != null
                            &&
                            (a = this.bitwise_or()) != null
            ) {
                return ast.cmpop_expr_pair ( ast.Lt() , a );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> gte_bitwise_or_cache = new HashMap<>();

    protected T gte_bitwise_or() {
        int p = this.mark();
        Memo<T> info = gte_bitwise_or_cache.get(p);
        if (info != null) {
            log("gte_bitwise_or() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("gte_bitwise_or() ...");
        this._level += 1;
        T result = _gte_bitwise_or();
        this._level -= 1;
        log("gte_bitwise_or() [fresh]-> ", result);
        if (result != null) {
            gte_bitwise_or_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _gte_bitwise_or() {
        // gte_bitwise_or: '>=' bitwise_or
        // type: CmpopExprPair*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T a;
            if (
                    (literal = this.expectStr(">=")) != null
                            &&
                            (a = this.bitwise_or()) != null
            ) {
                return ast.cmpop_expr_pair ( ast.GtE() , a );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> gt_bitwise_or_cache = new HashMap<>();

    protected T gt_bitwise_or() {
        int p = this.mark();
        Memo<T> info = gt_bitwise_or_cache.get(p);
        if (info != null) {
            log("gt_bitwise_or() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("gt_bitwise_or() ...");
        this._level += 1;
        T result = _gt_bitwise_or();
        this._level -= 1;
        log("gt_bitwise_or() [fresh]-> ", result);
        if (result != null) {
            gt_bitwise_or_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _gt_bitwise_or() {
        // gt_bitwise_or: '>' bitwise_or
        // type: CmpopExprPair*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T a;
            if (
                    (literal = this.expectStr('>')) != null
                            &&
                            (a = this.bitwise_or()) != null
            ) {
                return ast.cmpop_expr_pair ( ast.Gt() , a );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> notin_bitwise_or_cache = new HashMap<>();

    protected T notin_bitwise_or() {
        int p = this.mark();
        Memo<T> info = notin_bitwise_or_cache.get(p);
        if (info != null) {
            log("notin_bitwise_or() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("notin_bitwise_or() ...");
        this._level += 1;
        T result = _notin_bitwise_or();
        this._level -= 1;
        log("notin_bitwise_or() [fresh]-> ", result);
        if (result != null) {
            notin_bitwise_or_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _notin_bitwise_or() {
        // notin_bitwise_or: 'not' 'in' bitwise_or
        // type: CmpopExprPair*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            if (
                    this.expectKeyword("not") != null
                            &&
                            this.expectKeyword("in") != null
                            &&
                            (a = this.bitwise_or()) != null
            ) {
                return ast.cmpop_expr_pair ( ast.NotIn() , a );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> in_bitwise_or_cache = new HashMap<>();

    protected T in_bitwise_or() {
        int p = this.mark();
        Memo<T> info = in_bitwise_or_cache.get(p);
        if (info != null) {
            log("in_bitwise_or() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("in_bitwise_or() ...");
        this._level += 1;
        T result = _in_bitwise_or();
        this._level -= 1;
        log("in_bitwise_or() [fresh]-> ", result);
        if (result != null) {
            in_bitwise_or_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _in_bitwise_or() {
        // in_bitwise_or: 'in' bitwise_or
        // type: CmpopExprPair*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            if (
                    this.expectKeyword("in") != null
                            &&
                            (a = this.bitwise_or()) != null
            ) {
                return ast.cmpop_expr_pair ( ast.In() , a );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> isnot_bitwise_or_cache = new HashMap<>();

    protected T isnot_bitwise_or() {
        int p = this.mark();
        Memo<T> info = isnot_bitwise_or_cache.get(p);
        if (info != null) {
            log("isnot_bitwise_or() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("isnot_bitwise_or() ...");
        this._level += 1;
        T result = _isnot_bitwise_or();
        this._level -= 1;
        log("isnot_bitwise_or() [fresh]-> ", result);
        if (result != null) {
            isnot_bitwise_or_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _isnot_bitwise_or() {
        // isnot_bitwise_or: 'is' 'not' bitwise_or
        // type: CmpopExprPair*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            if (
                    this.expectKeyword("is") != null
                            &&
                            this.expectKeyword("not") != null
                            &&
                            (a = this.bitwise_or()) != null
            ) {
                return ast.cmpop_expr_pair ( ast.IsNot() , a );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> is_bitwise_or_cache = new HashMap<>();

    protected T is_bitwise_or() {
        int p = this.mark();
        Memo<T> info = is_bitwise_or_cache.get(p);
        if (info != null) {
            log("is_bitwise_or() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("is_bitwise_or() ...");
        this._level += 1;
        T result = _is_bitwise_or();
        this._level -= 1;
        log("is_bitwise_or() [fresh]-> ", result);
        if (result != null) {
            is_bitwise_or_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _is_bitwise_or() {
        // is_bitwise_or: 'is' bitwise_or
        // type: CmpopExprPair*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            if (
                    this.expectKeyword("is") != null
                            &&
                            (a = this.bitwise_or()) != null
            ) {
                return ast.cmpop_expr_pair ( ast.Is() , a );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> bitwise_or_cache = new HashMap<>();

    protected T bitwise_or() {
        int p = this.mark();
        Memo<T> info = bitwise_or_cache.get(p);
        if (info != null) {
            log("bitwise_or() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("bitwise_or() ...");
        T last_result = null;
        int last_mark = p;
        int depth = 0;
        bitwise_or_cache.put(p, new Memo<>(null, p));
        log("recursive bitwise_or() at " + p + " depth " + depth);
        while (true) {
            this.reset(p);
            this._level += 1;
            T result = _bitwise_or();
            int end_mark = this.mark();
            depth += 1;
            this._level -= 1;
            log("recursive bitwise_or() at " + p + " depth " + depth + ": ", result);
            if (result == null || end_mark <= last_mark)
                break;
            last_result = result;
            last_mark = end_mark;
            bitwise_or_cache.put(p, new Memo<>(result, end_mark));
        }
        this.reset(last_mark);
        if (last_result != null) {
            last_mark = this.mark();
        } else {
            last_mark = p;
            this.reset(last_mark);
        }
        log("bitwise_or() [fresh]-> ", last_result);
        bitwise_or_cache.put(p, new Memo<>(last_result, last_mark));
        return last_result;
    }

    private T _bitwise_or() {
        // bitwise_or: bitwise_or '|' bitwise_xor | bitwise_xor
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.bitwise_or()) != null
                            &&
                            (literal = this.expectStr('|')) != null
                            &&
                            (b = this.bitwise_xor()) != null
            ) {
                return ast.BinOp ( a , ast.BitOr() , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T bitwise_xor;
            if (
                    (bitwise_xor = this.bitwise_xor()) != null
            ) {
                return bitwise_xor;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> bitwise_xor_cache = new HashMap<>();

    protected T bitwise_xor() {
        int p = this.mark();
        Memo<T> info = bitwise_xor_cache.get(p);
        if (info != null) {
            log("bitwise_xor() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("bitwise_xor() ...");
        T last_result = null;
        int last_mark = p;
        int depth = 0;
        bitwise_xor_cache.put(p, new Memo<>(null, p));
        log("recursive bitwise_xor() at " + p + " depth " + depth);
        while (true) {
            this.reset(p);
            this._level += 1;
            T result = _bitwise_xor();
            int end_mark = this.mark();
            depth += 1;
            this._level -= 1;
            log("recursive bitwise_xor() at " + p + " depth " + depth + ": ", result);
            if (result == null || end_mark <= last_mark)
                break;
            last_result = result;
            last_mark = end_mark;
            bitwise_xor_cache.put(p, new Memo<>(result, end_mark));
        }
        this.reset(last_mark);
        if (last_result != null) {
            last_mark = this.mark();
        } else {
            last_mark = p;
            this.reset(last_mark);
        }
        log("bitwise_xor() [fresh]-> ", last_result);
        bitwise_xor_cache.put(p, new Memo<>(last_result, last_mark));
        return last_result;
    }

    private T _bitwise_xor() {
        // bitwise_xor: bitwise_xor '^' bitwise_and | bitwise_and
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.bitwise_xor()) != null
                            &&
                            (literal = this.expectStr('^')) != null
                            &&
                            (b = this.bitwise_and()) != null
            ) {
                return ast.BinOp ( a , ast.BitXor() , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T bitwise_and;
            if (
                    (bitwise_and = this.bitwise_and()) != null
            ) {
                return bitwise_and;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> bitwise_and_cache = new HashMap<>();

    protected T bitwise_and() {
        int p = this.mark();
        Memo<T> info = bitwise_and_cache.get(p);
        if (info != null) {
            log("bitwise_and() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("bitwise_and() ...");
        T last_result = null;
        int last_mark = p;
        int depth = 0;
        bitwise_and_cache.put(p, new Memo<>(null, p));
        log("recursive bitwise_and() at " + p + " depth " + depth);
        while (true) {
            this.reset(p);
            this._level += 1;
            T result = _bitwise_and();
            int end_mark = this.mark();
            depth += 1;
            this._level -= 1;
            log("recursive bitwise_and() at " + p + " depth " + depth + ": ", result);
            if (result == null || end_mark <= last_mark)
                break;
            last_result = result;
            last_mark = end_mark;
            bitwise_and_cache.put(p, new Memo<>(result, end_mark));
        }
        this.reset(last_mark);
        if (last_result != null) {
            last_mark = this.mark();
        } else {
            last_mark = p;
            this.reset(last_mark);
        }
        log("bitwise_and() [fresh]-> ", last_result);
        bitwise_and_cache.put(p, new Memo<>(last_result, last_mark));
        return last_result;
    }

    private T _bitwise_and() {
        // bitwise_and: bitwise_and '&' shift_expr | shift_expr
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.bitwise_and()) != null
                            &&
                            (literal = this.expectStr('&')) != null
                            &&
                            (b = this.shift_expr()) != null
            ) {
                return ast.BinOp ( a , ast.BitAnd() , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T shift_expr;
            if (
                    (shift_expr = this.shift_expr()) != null
            ) {
                return shift_expr;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> shift_expr_cache = new HashMap<>();

    protected T shift_expr() {
        int p = this.mark();
        Memo<T> info = shift_expr_cache.get(p);
        if (info != null) {
            log("shift_expr() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("shift_expr() ...");
        T last_result = null;
        int last_mark = p;
        int depth = 0;
        shift_expr_cache.put(p, new Memo<>(null, p));
        log("recursive shift_expr() at " + p + " depth " + depth);
        while (true) {
            this.reset(p);
            this._level += 1;
            T result = _shift_expr();
            int end_mark = this.mark();
            depth += 1;
            this._level -= 1;
            log("recursive shift_expr() at " + p + " depth " + depth + ": ", result);
            if (result == null || end_mark <= last_mark)
                break;
            last_result = result;
            last_mark = end_mark;
            shift_expr_cache.put(p, new Memo<>(result, end_mark));
        }
        this.reset(last_mark);
        if (last_result != null) {
            last_mark = this.mark();
        } else {
            last_mark = p;
            this.reset(last_mark);
        }
        log("shift_expr() [fresh]-> ", last_result);
        shift_expr_cache.put(p, new Memo<>(last_result, last_mark));
        return last_result;
    }

    private T _shift_expr() {
        // shift_expr: shift_expr '<<' sum | shift_expr '>>' sum | sum
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.shift_expr()) != null
                            &&
                            (literal = this.expectStr("<<")) != null
                            &&
                            (b = this.sum()) != null
            ) {
                return ast.BinOp ( a , ast.LShift() , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.shift_expr()) != null
                            &&
                            (literal = this.expectStr(">>")) != null
                            &&
                            (b = this.sum()) != null
            ) {
                return ast.BinOp ( a , ast.RShift() , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T sum;
            if (
                    (sum = this.sum()) != null
            ) {
                return sum;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> sum_cache = new HashMap<>();

    protected T sum() {
        int p = this.mark();
        Memo<T> info = sum_cache.get(p);
        if (info != null) {
            log("sum() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("sum() ...");
        T last_result = null;
        int last_mark = p;
        int depth = 0;
        sum_cache.put(p, new Memo<>(null, p));
        log("recursive sum() at " + p + " depth " + depth);
        while (true) {
            this.reset(p);
            this._level += 1;
            T result = _sum();
            int end_mark = this.mark();
            depth += 1;
            this._level -= 1;
            log("recursive sum() at " + p + " depth " + depth + ": ", result);
            if (result == null || end_mark <= last_mark)
                break;
            last_result = result;
            last_mark = end_mark;
            sum_cache.put(p, new Memo<>(result, end_mark));
        }
        this.reset(last_mark);
        if (last_result != null) {
            last_mark = this.mark();
        } else {
            last_mark = p;
            this.reset(last_mark);
        }
        log("sum() [fresh]-> ", last_result);
        sum_cache.put(p, new Memo<>(last_result, last_mark));
        return last_result;
    }

    private T _sum() {
        // sum: sum '+' term | sum '-' term | term
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.sum()) != null
                            &&
                            (literal = this.expectStr('+')) != null
                            &&
                            (b = this.term()) != null
            ) {
                return ast.BinOp ( a , ast.Add() , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.sum()) != null
                            &&
                            (literal = this.expectStr('-')) != null
                            &&
                            (b = this.term()) != null
            ) {
                return ast.BinOp ( a , ast.Sub() , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T term;
            if (
                    (term = this.term()) != null
            ) {
                return term;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> term_cache = new HashMap<>();

    protected T term() {
        int p = this.mark();
        Memo<T> info = term_cache.get(p);
        if (info != null) {
            log("term() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("term() ...");
        T last_result = null;
        int last_mark = p;
        int depth = 0;
        term_cache.put(p, new Memo<>(null, p));
        log("recursive term() at " + p + " depth " + depth);
        while (true) {
            this.reset(p);
            this._level += 1;
            T result = _term();
            int end_mark = this.mark();
            depth += 1;
            this._level -= 1;
            log("recursive term() at " + p + " depth " + depth + ": ", result);
            if (result == null || end_mark <= last_mark)
                break;
            last_result = result;
            last_mark = end_mark;
            term_cache.put(p, new Memo<>(result, end_mark));
        }
        this.reset(last_mark);
        if (last_result != null) {
            last_mark = this.mark();
        } else {
            last_mark = p;
            this.reset(last_mark);
        }
        log("term() [fresh]-> ", last_result);
        term_cache.put(p, new Memo<>(last_result, last_mark));
        return last_result;
    }

    private T _term() {
        // term: term '*' factor | term '/' factor | term '//' factor | term '%' factor | term '@' factor | factor
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.term()) != null
                            &&
                            (literal = this.expectStr('*')) != null
                            &&
                            (b = this.factor()) != null
            ) {
                return ast.BinOp ( a , ast.Mult() , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.term()) != null
                            &&
                            (literal = this.expectStr('/')) != null
                            &&
                            (b = this.factor()) != null
            ) {
                return ast.BinOp ( a , ast.Div() , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.term()) != null
                            &&
                            (literal = this.expectStr("//")) != null
                            &&
                            (b = this.factor()) != null
            ) {
                return ast.BinOp ( a , ast.FloorDiv() , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.term()) != null
                            &&
                            (literal = this.expectStr('%')) != null
                            &&
                            (b = this.factor()) != null
            ) {
                return ast.BinOp ( a , ast.Mod() , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.term()) != null
                            &&
                            (literal = this.expectStr('@')) != null
                            &&
                            (b = this.factor()) != null
            ) {
                return ast.BinOp ( a , ast.MatMult() , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T factor;
            if (
                    (factor = this.factor()) != null
            ) {
                return factor;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> factor_cache = new HashMap<>();

    protected T factor() {
        int p = this.mark();
        Memo<T> info = factor_cache.get(p);
        if (info != null) {
            log("factor() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("factor() ...");
        this._level += 1;
        T result = _factor();
        this._level -= 1;
        log("factor() [fresh]-> ", result);
        if (result != null) {
            factor_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _factor() {
        // factor: '+' factor | '-' factor | '~' factor | power
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T a;
            if (
                    (literal = this.expectStr('+')) != null
                            &&
                            (a = this.factor()) != null
            ) {
                return ast.UnaryOp ( ast.UAdd() , a , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            Token literal;
            T a;
            if (
                    (literal = this.expectStr('-')) != null
                            &&
                            (a = this.factor()) != null
            ) {
                return ast.UnaryOp ( ast.USub() , a , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            Token literal;
            T a;
            if (
                    (literal = this.expectStr('~')) != null
                            &&
                            (a = this.factor()) != null
            ) {
                return ast.UnaryOp ( ast.Invert() , a , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T power;
            if (
                    (power = this.power()) != null
            ) {
                return power;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> power_cache = new HashMap<>();

    protected T power() {
        int p = this.mark();
        Memo<T> info = power_cache.get(p);
        if (info != null) {
            log("power() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("power() ...");
        this._level += 1;
        T result = _power();
        this._level -= 1;
        log("power() [fresh]-> ", result);
        if (result != null) {
            power_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _power() {
        // power: await_primary '**' factor | await_primary
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.await_primary()) != null
                            &&
                            (literal = this.expectStr("**")) != null
                            &&
                            (b = this.factor()) != null
            ) {
                return ast.BinOp ( a , ast.Pow() , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T await_primary;
            if (
                    (await_primary = this.await_primary()) != null
            ) {
                return await_primary;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> await_primary_cache = new HashMap<>();

    protected T await_primary() {
        int p = this.mark();
        Memo<T> info = await_primary_cache.get(p);
        if (info != null) {
            log("await_primary() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("await_primary() ...");
        this._level += 1;
        T result = _await_primary();
        this._level -= 1;
        log("await_primary() [fresh]-> ", result);
        if (result != null) {
            await_primary_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _await_primary() {
        // await_primary: AWAIT primary | primary
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            if (
                    this.expect(TokenType.AWAIT) != null
                            &&
                            (a = this.primary()) != null
            ) {
                return ast.Await ( a , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T primary;
            if (
                    (primary = this.primary()) != null
            ) {
                return primary;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> primary_cache = new HashMap<>();

    protected T primary() {
        int p = this.mark();
        Memo<T> info = primary_cache.get(p);
        if (info != null) {
            log("primary() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("primary() ...");
        T last_result = null;
        int last_mark = p;
        int depth = 0;
        primary_cache.put(p, new Memo<>(null, p));
        log("recursive primary() at " + p + " depth " + depth);
        while (true) {
            this.reset(p);
            this._level += 1;
            T result = _primary();
            int end_mark = this.mark();
            depth += 1;
            this._level -= 1;
            log("recursive primary() at " + p + " depth " + depth + ": ", result);
            if (result == null || end_mark <= last_mark)
                break;
            last_result = result;
            last_mark = end_mark;
            primary_cache.put(p, new Memo<>(result, end_mark));
        }
        this.reset(last_mark);
        if (last_result != null) {
            last_mark = this.mark();
        } else {
            last_mark = p;
            this.reset(last_mark);
        }
        log("primary() [fresh]-> ", last_result);
        primary_cache.put(p, new Memo<>(last_result, last_mark));
        return last_result;
    }

    private T _primary() {
        // primary: primary '.' NAME | primary genexp | primary '(' arguments? ')' | primary '[' slices ']' | atom
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.primary()) != null
                            &&
                            (literal = this.expectStr('.')) != null
                            &&
                            (b = this.name()) != null
            ) {
                return ast.Attribute ( a , ast.get_expr_name(b) , ast.Load() , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            T b;
            if (
                    (a = this.primary()) != null
                            &&
                            (b = this.genexp()) != null
            ) {
                return ast.Call ( a , ast.singleton_seq ( b ) , null , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            Token literal;
            T b;
            Token literal_1;
            if (
                    (a = this.primary()) != null
                            &&
                            (literal = this.expectStr('(')) != null
                            &&
                            ((b = this.arguments()) != null || true)
                            &&
                            (literal_1 = this.expectStr(')')) != null
            ) {
                return ast.Call ( a , (b != null) ? ast.get_call_args(b) : null , (b != null) ? ast.get_call_keywords(b) : null , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            Token literal;
            T b;
            Token literal_1;
            if (
                    (a = this.primary()) != null
                            &&
                            (literal = this.expectStr('[')) != null
                            &&
                            (b = this.slices()) != null
                            &&
                            (literal_1 = this.expectStr(']')) != null
            ) {
                return ast.Subscript ( a , b , ast.Load() , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T atom;
            if (
                    (atom = this.atom()) != null
            ) {
                return atom;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> slices_cache = new HashMap<>();

    protected T slices() {
        int p = this.mark();
        Memo<T> info = slices_cache.get(p);
        if (info != null) {
            log("slices() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("slices() ...");
        this._level += 1;
        T result = _slices();
        this._level -= 1;
        log("slices() [fresh]-> ", result);
        if (result != null) {
            slices_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _slices() {
        // slices: slice !',' | ','.slice+ ','?
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            if (
                    (a = this.slice()) != null
                            &&
                            this.negative_lookahead(this::expectStr, ',')
            ) {
                return a;
            }
            this.reset(mark);
        }
        {
            T[] a;
            Token literal;
            if (
                    (a = this._gather_93()) != null
                            &&
                            ((literal = this.expectStr(',')) != null || true)
            ) {
                return ast.Tuple ( a , ast.Load() , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> slice_cache = new HashMap<>();

    protected T slice() {
        int p = this.mark();
        Memo<T> info = slice_cache.get(p);
        if (info != null) {
            log("slice() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("slice() ...");
        this._level += 1;
        T result = _slice();
        this._level -= 1;
        log("slice() [fresh]-> ", result);
        if (result != null) {
            slice_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _slice() {
        // slice: expression? ':' expression? [':' expression?] | expression
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T b;
            T c;
            if (
                    ((a = this.expression()) != null || true)
                            &&
                            (literal = this.expectStr(':')) != null
                            &&
                            ((b = this.expression()) != null || true)
                            &&
                            ((c = this._tmp_95()) != null || true)
            ) {
                return ast.Slice ( a , b , c , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            if (
                    (a = this.expression()) != null
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> atom_cache = new HashMap<>();

    protected T atom() {
        int p = this.mark();
        Memo<T> info = atom_cache.get(p);
        if (info != null) {
            log("atom() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("atom() ...");
        this._level += 1;
        T result = _atom();
        this._level -= 1;
        log("atom() [fresh]-> ", result);
        if (result != null) {
            atom_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _atom() {
        // atom: NAME | 'True' | 'False' | 'None' | &STRING strings | NUMBER | &'(' (tuple | group | genexp) | &'[' (list | listcomp) | &'{' (dict | set | dictcomp | setcomp) | '...'
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T name;
            if (
                    (name = this.name()) != null
            ) {
                return name;
            }
            this.reset(mark);
        }
        {
            if (
                    this.expectKeyword("True") != null
            ) {
                return ast.Constant ( ast.True() , null , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            if (
                    this.expectKeyword("False") != null
            ) {
                return ast.Constant ( ast.False() , null , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            if (
                    this.expectKeyword("None") != null
            ) {
                return ast.Constant ( ast.None() , null , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T strings;
            if (
                    this.positive_lookahead(this::string)
                            &&
                            (strings = this.strings()) != null
            ) {
                return strings;
            }
            this.reset(mark);
        }
        {
            Token number;
            if (
                    (number = this.number()) != null
            ) {
                return ast.from_token(number);
            }
            this.reset(mark);
        }
        {
            T _tmp_96;
            if (
                    this.positive_lookahead(this::expectStr, '(')
                            &&
                            (_tmp_96 = this._tmp_96()) != null
            ) {
                return _tmp_96;
            }
            this.reset(mark);
        }
        {
            T _tmp_97;
            if (
                    this.positive_lookahead(this::expectStr, '[')
                            &&
                            (_tmp_97 = this._tmp_97()) != null
            ) {
                return _tmp_97;
            }
            this.reset(mark);
        }
        {
            T _tmp_98;
            if (
                    this.positive_lookahead(this::expectStr, '{')
                            &&
                            (_tmp_98 = this._tmp_98()) != null
            ) {
                return _tmp_98;
            }
            this.reset(mark);
        }
        {
            Token literal;
            if (
                    (literal = this.expectStr("...")) != null
            ) {
                return ast.Constant ( ast.Ellipsis() , null , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> strings_cache = new HashMap<>();

    protected T strings() {
        int p = this.mark();
        Memo<T> info = strings_cache.get(p);
        if (info != null) {
            log("strings() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("strings() ...");
        this._level += 1;
        T result = _strings();
        this._level -= 1;
        log("strings() [fresh]-> ", result);
        if (result != null) {
            strings_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _strings() {
        // strings: STRING+
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            if (
                    (a = null_if_empty(this._loop1_99())) != null
            ) {
                return ast.concatenate_strings ( a );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> list_cache = new HashMap<>();

    protected T list() {
        int p = this.mark();
        Memo<T> info = list_cache.get(p);
        if (info != null) {
            log("list() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("list() ...");
        this._level += 1;
        T result = _list();
        this._level -= 1;
        log("list() [fresh]-> ", result);
        if (result != null) {
            list_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _list() {
        // list: '[' star_named_expressions? ']'
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T[] a;
            Token literal_1;
            if (
                    (literal = this.expectStr('[')) != null
                            &&
                            ((a = this.star_named_expressions()) != null || true)
                            &&
                            (literal_1 = this.expectStr(']')) != null
            ) {
                return ast.List ( a , ast.Load() , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> listcomp_cache = new HashMap<>();

    protected T listcomp() {
        int p = this.mark();
        Memo<T> info = listcomp_cache.get(p);
        if (info != null) {
            log("listcomp() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("listcomp() ...");
        this._level += 1;
        T result = _listcomp();
        this._level -= 1;
        log("listcomp() [fresh]-> ", result);
        if (result != null) {
            listcomp_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _listcomp() {
        // listcomp: '[' named_expression ~ for_if_clauses ']'
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T a;
            T[] b;
            Token literal_1;
            if (
                    (literal = this.expectStr('[')) != null
                            &&
                            (a = this.named_expression()) != null
                            &&
                            (cut = true)
                            &&
                            (b = this.for_if_clauses()) != null
                            &&
                            (literal_1 = this.expectStr(']')) != null
            ) {
                return ast.ListComp ( a , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> tuple_cache = new HashMap<>();

    protected T tuple() {
        int p = this.mark();
        Memo<T> info = tuple_cache.get(p);
        if (info != null) {
            log("tuple() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("tuple() ...");
        this._level += 1;
        T result = _tuple();
        this._level -= 1;
        log("tuple() [fresh]-> ", result);
        if (result != null) {
            tuple_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _tuple() {
        // tuple: '(' [star_named_expression ',' star_named_expressions?] ')'
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T[] a;
            Token literal_1;
            if (
                    (literal = this.expectStr('(')) != null
                            &&
                            ((a = this._tmp_100()) != null || true)
                            &&
                            (literal_1 = this.expectStr(')')) != null
            ) {
                return ast.Tuple ( a , ast.Load() , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> group_cache = new HashMap<>();

    protected T group() {
        int p = this.mark();
        Memo<T> info = group_cache.get(p);
        if (info != null) {
            log("group() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("group() ...");
        this._level += 1;
        T result = _group();
        this._level -= 1;
        log("group() [fresh]-> ", result);
        if (result != null) {
            group_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _group() {
        // group: '(' (yield_expr | named_expression) ')'
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T a;
            Token literal_1;
            if (
                    (literal = this.expectStr('(')) != null
                            &&
                            (a = this._tmp_101()) != null
                            &&
                            (literal_1 = this.expectStr(')')) != null
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> genexp_cache = new HashMap<>();

    protected T genexp() {
        int p = this.mark();
        Memo<T> info = genexp_cache.get(p);
        if (info != null) {
            log("genexp() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("genexp() ...");
        this._level += 1;
        T result = _genexp();
        this._level -= 1;
        log("genexp() [fresh]-> ", result);
        if (result != null) {
            genexp_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _genexp() {
        // genexp: '(' expression ~ for_if_clauses ')'
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T a;
            T[] b;
            Token literal_1;
            if (
                    (literal = this.expectStr('(')) != null
                            &&
                            (a = this.expression()) != null
                            &&
                            (cut = true)
                            &&
                            (b = this.for_if_clauses()) != null
                            &&
                            (literal_1 = this.expectStr(')')) != null
            ) {
                return ast.GeneratorExp ( a , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> set_cache = new HashMap<>();

    protected T set() {
        int p = this.mark();
        Memo<T> info = set_cache.get(p);
        if (info != null) {
            log("set() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("set() ...");
        this._level += 1;
        T result = _set();
        this._level -= 1;
        log("set() [fresh]-> ", result);
        if (result != null) {
            set_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _set() {
        // set: '{' expressions_list '}'
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T[] a;
            Token literal_1;
            if (
                    (literal = this.expectStr('{')) != null
                            &&
                            (a = this.expressions_list()) != null
                            &&
                            (literal_1 = this.expectStr('}')) != null
            ) {
                return ast.Set ( a , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> setcomp_cache = new HashMap<>();

    protected T setcomp() {
        int p = this.mark();
        Memo<T> info = setcomp_cache.get(p);
        if (info != null) {
            log("setcomp() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("setcomp() ...");
        this._level += 1;
        T result = _setcomp();
        this._level -= 1;
        log("setcomp() [fresh]-> ", result);
        if (result != null) {
            setcomp_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _setcomp() {
        // setcomp: '{' expression ~ for_if_clauses '}'
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T a;
            T[] b;
            Token literal_1;
            if (
                    (literal = this.expectStr('{')) != null
                            &&
                            (a = this.expression()) != null
                            &&
                            (cut = true)
                            &&
                            (b = this.for_if_clauses()) != null
                            &&
                            (literal_1 = this.expectStr('}')) != null
            ) {
                return ast.SetComp ( a , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> dict_cache = new HashMap<>();

    protected T dict() {
        int p = this.mark();
        Memo<T> info = dict_cache.get(p);
        if (info != null) {
            log("dict() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("dict() ...");
        this._level += 1;
        T result = _dict();
        this._level -= 1;
        log("dict() [fresh]-> ", result);
        if (result != null) {
            dict_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _dict() {
        // dict: '{' double_starred_kvpairs? '}'
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T[] a;
            Token literal_1;
            if (
                    (literal = this.expectStr('{')) != null
                            &&
                            ((a = this.double_starred_kvpairs()) != null || true)
                            &&
                            (literal_1 = this.expectStr('}')) != null
            ) {
                return ast.Dict ( ast.get_keys ( a ) , ast.get_values ( a ) , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> dictcomp_cache = new HashMap<>();

    protected T dictcomp() {
        int p = this.mark();
        Memo<T> info = dictcomp_cache.get(p);
        if (info != null) {
            log("dictcomp() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("dictcomp() ...");
        this._level += 1;
        T result = _dictcomp();
        this._level -= 1;
        log("dictcomp() [fresh]-> ", result);
        if (result != null) {
            dictcomp_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _dictcomp() {
        // dictcomp: '{' kvpair for_if_clauses '}'
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T a;
            T[] b;
            Token literal_1;
            if (
                    (literal = this.expectStr('{')) != null
                            &&
                            (a = this.kvpair()) != null
                            &&
                            (b = this.for_if_clauses()) != null
                            &&
                            (literal_1 = this.expectStr('}')) != null
            ) {
                return ast.DictComp ( ast.get_pair_key(a) , ast.get_pair_value(a) , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> double_starred_kvpairs_cache = new HashMap<>();

    protected T[] double_starred_kvpairs() {
        int p = this.mark();
        Memo<T[]> info = double_starred_kvpairs_cache.get(p);
        if (info != null) {
            log("double_starred_kvpairs() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("double_starred_kvpairs() ...");
        this._level += 1;
        T[] result = _double_starred_kvpairs();
        this._level -= 1;
        log("double_starred_kvpairs() [fresh]-> ", result);
        if (result != null) {
            double_starred_kvpairs_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _double_starred_kvpairs() {
        // double_starred_kvpairs: ','.double_starred_kvpair+ ','?
        // type: asdl_seq*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            Token literal;
            if (
                    (a = this._gather_102()) != null
                            &&
                            ((literal = this.expectStr(',')) != null || true)
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> double_starred_kvpair_cache = new HashMap<>();

    protected T double_starred_kvpair() {
        int p = this.mark();
        Memo<T> info = double_starred_kvpair_cache.get(p);
        if (info != null) {
            log("double_starred_kvpair() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("double_starred_kvpair() ...");
        this._level += 1;
        T result = _double_starred_kvpair();
        this._level -= 1;
        log("double_starred_kvpair() [fresh]-> ", result);
        if (result != null) {
            double_starred_kvpair_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _double_starred_kvpair() {
        // double_starred_kvpair: '**' bitwise_or | kvpair
        // type: KeyValuePair*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T a;
            if (
                    (literal = this.expectStr("**")) != null
                            &&
                            (a = this.bitwise_or()) != null
            ) {
                return ast.key_value_pair ( null , a );
            }
            this.reset(mark);
        }
        {
            T kvpair;
            if (
                    (kvpair = this.kvpair()) != null
            ) {
                return kvpair;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> kvpair_cache = new HashMap<>();

    protected T kvpair() {
        int p = this.mark();
        Memo<T> info = kvpair_cache.get(p);
        if (info != null) {
            log("kvpair() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("kvpair() ...");
        this._level += 1;
        T result = _kvpair();
        this._level -= 1;
        log("kvpair() [fresh]-> ", result);
        if (result != null) {
            kvpair_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _kvpair() {
        // kvpair: expression ':' expression
        // type: KeyValuePair*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.expression()) != null
                            &&
                            (literal = this.expectStr(':')) != null
                            &&
                            (b = this.expression()) != null
            ) {
                return ast.key_value_pair ( a , b );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> for_if_clauses_cache = new HashMap<>();

    protected T[] for_if_clauses() {
        int p = this.mark();
        Memo<T[]> info = for_if_clauses_cache.get(p);
        if (info != null) {
            log("for_if_clauses() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("for_if_clauses() ...");
        this._level += 1;
        T[] result = _for_if_clauses();
        this._level -= 1;
        log("for_if_clauses() [fresh]-> ", result);
        if (result != null) {
            for_if_clauses_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _for_if_clauses() {
        // for_if_clauses: for_if_clause+
        // type: asdl_comprehension_seq*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            if (
                    (a = null_if_empty(this._loop1_104())) != null
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> for_if_clause_cache = new HashMap<>();

    protected T for_if_clause() {
        int p = this.mark();
        Memo<T> info = for_if_clause_cache.get(p);
        if (info != null) {
            log("for_if_clause() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("for_if_clause() ...");
        this._level += 1;
        T result = _for_if_clause();
        this._level -= 1;
        log("for_if_clause() [fresh]-> ", result);
        if (result != null) {
            for_if_clause_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _for_if_clause() {
        // for_if_clause: ASYNC 'for' star_targets 'in' ~ disjunction (('if' disjunction))* | 'for' star_targets 'in' ~ disjunction (('if' disjunction))*
        // type: comprehension_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            T b;
            T[] c;
            if (
                    this.expect(TokenType.ASYNC) != null
                            &&
                            this.expectKeyword("for") != null
                            &&
                            (a = this.star_targets()) != null
                            &&
                            this.expectKeyword("in") != null
                            &&
                            (cut = true)
                            &&
                            (b = this.disjunction()) != null
                            &&
                            (c = this._loop0_105()) != null
            ) {
                return ast.comprehension ( a , b , c , 1 );
            }
            this.reset(mark);
        }
        {
            T a;
            T b;
            T[] c;
            if (
                    this.expectKeyword("for") != null
                            &&
                            (a = this.star_targets()) != null
                            &&
                            this.expectKeyword("in") != null
                            &&
                            (cut = true)
                            &&
                            (b = this.disjunction()) != null
                            &&
                            (c = this._loop0_106()) != null
            ) {
                return ast.comprehension ( a , b , c , 0 );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> yield_expr_cache = new HashMap<>();

    protected T yield_expr() {
        int p = this.mark();
        Memo<T> info = yield_expr_cache.get(p);
        if (info != null) {
            log("yield_expr() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("yield_expr() ...");
        this._level += 1;
        T result = _yield_expr();
        this._level -= 1;
        log("yield_expr() [fresh]-> ", result);
        if (result != null) {
            yield_expr_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _yield_expr() {
        // yield_expr: 'yield' 'from' expression | 'yield' star_expressions?
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            if (
                    this.expectKeyword("yield") != null
                            &&
                            this.expectKeyword("from") != null
                            &&
                            (a = this.expression()) != null
            ) {
                return ast.YieldFrom ( a , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            if (
                    this.expectKeyword("yield") != null
                            &&
                            ((a = this.star_expressions()) != null || true)
            ) {
                return ast.Yield ( a , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> arguments_cache = new HashMap<>();

    protected T arguments() {
        int p = this.mark();
        Memo<T> info = arguments_cache.get(p);
        if (info != null) {
            log("arguments() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("arguments() ...");
        this._level += 1;
        T result = _arguments();
        this._level -= 1;
        log("arguments() [fresh]-> ", result);
        if (result != null) {
            arguments_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _arguments() {
        // arguments: args ','? &')'
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            if (
                    (a = this.args()) != null
                            &&
                            ((literal = this.expectStr(',')) != null || true)
                            &&
                            this.positive_lookahead(this::expectStr, ')')
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> args_cache = new HashMap<>();

    protected T args() {
        int p = this.mark();
        Memo<T> info = args_cache.get(p);
        if (info != null) {
            log("args() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("args() ...");
        this._level += 1;
        T result = _args();
        this._level -= 1;
        log("args() [fresh]-> ", result);
        if (result != null) {
            args_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _args() {
        // args: ','.(starred_expression | named_expression !'=')+ [',' kwargs] | kwargs
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            T[] b;
            if (
                    (a = this._gather_107()) != null
                            &&
                            ((b = this._tmp_109()) != null || true)
            ) {
                return ast.collect_call_seqs ( a , b , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T[] a;
            if (
                    (a = this.kwargs()) != null
            ) {
                return ast.Call ( ast.dummy_name ( ) , ast.seq_extract_starred_exprs ( a ) , ast.seq_delete_starred_exprs ( a ) , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> kwargs_cache = new HashMap<>();

    protected T[] kwargs() {
        int p = this.mark();
        Memo<T[]> info = kwargs_cache.get(p);
        if (info != null) {
            log("kwargs() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("kwargs() ...");
        this._level += 1;
        T[] result = _kwargs();
        this._level -= 1;
        log("kwargs() [fresh]-> ", result);
        if (result != null) {
            kwargs_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _kwargs() {
        // kwargs: ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+ | ','.kwarg_or_starred+ | ','.kwarg_or_double_starred+
        // type: asdl_seq*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            Token literal;
            T[] b;
            if (
                    (a = this._gather_110()) != null
                            &&
                            (literal = this.expectStr(',')) != null
                            &&
                            (b = this._gather_112()) != null
            ) {
                return ast.join_sequences ( a , b );
            }
            this.reset(mark);
        }
        {
            T[] _gather_114;
            if (
                    (_gather_114 = this._gather_114()) != null
            ) {
                return _gather_114;
            }
            this.reset(mark);
        }
        {
            T[] _gather_116;
            if (
                    (_gather_116 = this._gather_116()) != null
            ) {
                return _gather_116;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> starred_expression_cache = new HashMap<>();

    protected T starred_expression() {
        int p = this.mark();
        Memo<T> info = starred_expression_cache.get(p);
        if (info != null) {
            log("starred_expression() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("starred_expression() ...");
        this._level += 1;
        T result = _starred_expression();
        this._level -= 1;
        log("starred_expression() [fresh]-> ", result);
        if (result != null) {
            starred_expression_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _starred_expression() {
        // starred_expression: '*' expression
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T a;
            if (
                    (literal = this.expectStr('*')) != null
                            &&
                            (a = this.expression()) != null
            ) {
                return ast.Starred ( a , ast.Load() , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> kwarg_or_starred_cache = new HashMap<>();

    protected T kwarg_or_starred() {
        int p = this.mark();
        Memo<T> info = kwarg_or_starred_cache.get(p);
        if (info != null) {
            log("kwarg_or_starred() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("kwarg_or_starred() ...");
        this._level += 1;
        T result = _kwarg_or_starred();
        this._level -= 1;
        log("kwarg_or_starred() [fresh]-> ", result);
        if (result != null) {
            kwarg_or_starred_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _kwarg_or_starred() {
        // kwarg_or_starred: NAME '=' expression | starred_expression
        // type: KeywordOrStarred*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.name()) != null
                            &&
                            (literal = this.expectStr('=')) != null
                            &&
                            (b = this.expression()) != null
            ) {
                return ast.keyword_or_starred ( ast.keyword ( ast.get_expr_name(a) , b , line_no , col_offset ) , 1 );
            }
            this.reset(mark);
        }
        {
            T a;
            if (
                    (a = this.starred_expression()) != null
            ) {
                return ast.keyword_or_starred ( a , 0 );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> kwarg_or_double_starred_cache = new HashMap<>();

    protected T kwarg_or_double_starred() {
        int p = this.mark();
        Memo<T> info = kwarg_or_double_starred_cache.get(p);
        if (info != null) {
            log("kwarg_or_double_starred() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("kwarg_or_double_starred() ...");
        this._level += 1;
        T result = _kwarg_or_double_starred();
        this._level -= 1;
        log("kwarg_or_double_starred() [fresh]-> ", result);
        if (result != null) {
            kwarg_or_double_starred_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _kwarg_or_double_starred() {
        // kwarg_or_double_starred: NAME '=' expression | '**' expression
        // type: KeywordOrStarred*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.name()) != null
                            &&
                            (literal = this.expectStr('=')) != null
                            &&
                            (b = this.expression()) != null
            ) {
                return ast.keyword_or_starred ( ast.keyword ( ast.get_expr_name(a) , b , line_no , col_offset ) , 1 );
            }
            this.reset(mark);
        }
        {
            Token literal;
            T a;
            if (
                    (literal = this.expectStr("**")) != null
                            &&
                            (a = this.expression()) != null
            ) {
                return ast.keyword_or_starred ( ast.keyword ( null , a , line_no , col_offset ) , 1 );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> star_targets_cache = new HashMap<>();

    protected T star_targets() {
        int p = this.mark();
        Memo<T> info = star_targets_cache.get(p);
        if (info != null) {
            log("star_targets() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("star_targets() ...");
        this._level += 1;
        T result = _star_targets();
        this._level -= 1;
        log("star_targets() [fresh]-> ", result);
        if (result != null) {
            star_targets_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _star_targets() {
        // star_targets: star_target !',' | star_target ((',' star_target))* ','?
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            if (
                    (a = this.star_target()) != null
                            &&
                            this.negative_lookahead(this::expectStr, ',')
            ) {
                return a;
            }
            this.reset(mark);
        }
        {
            T a;
            T[] b;
            Token literal;
            if (
                    (a = this.star_target()) != null
                            &&
                            (b = this._loop0_118()) != null
                            &&
                            ((literal = this.expectStr(',')) != null || true)
            ) {
                return ast.Tuple ( ast.seq_insert_in_front ( a , b ) , ast.Store() , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> star_targets_seq_cache = new HashMap<>();

    protected T[] star_targets_seq() {
        int p = this.mark();
        Memo<T[]> info = star_targets_seq_cache.get(p);
        if (info != null) {
            log("star_targets_seq() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("star_targets_seq() ...");
        this._level += 1;
        T[] result = _star_targets_seq();
        this._level -= 1;
        log("star_targets_seq() [fresh]-> ", result);
        if (result != null) {
            star_targets_seq_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _star_targets_seq() {
        // star_targets_seq: ','.star_target+ ','?
        // type: asdl_expr_seq*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            Token literal;
            if (
                    (a = this._gather_119()) != null
                            &&
                            ((literal = this.expectStr(',')) != null || true)
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> star_target_cache = new HashMap<>();

    protected T star_target() {
        int p = this.mark();
        Memo<T> info = star_target_cache.get(p);
        if (info != null) {
            log("star_target() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("star_target() ...");
        this._level += 1;
        T result = _star_target();
        this._level -= 1;
        log("star_target() [fresh]-> ", result);
        if (result != null) {
            star_target_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _star_target() {
        // star_target: '*' (!'*' star_target) | t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead | star_atom
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T a;
            if (
                    (literal = this.expectStr('*')) != null
                            &&
                            (a = this._tmp_121()) != null
            ) {
                return ast.Starred ( ast.set_expr_context ( a , ast.Store() ) , ast.Store() , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.t_primary()) != null
                            &&
                            (literal = this.expectStr('.')) != null
                            &&
                            (b = this.name()) != null
                            &&
                            this.negative_lookahead(this::t_lookahead)
            ) {
                return ast.Attribute ( a , ast.get_expr_name(b) , ast.Store() , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            Token literal;
            T b;
            Token literal_1;
            if (
                    (a = this.t_primary()) != null
                            &&
                            (literal = this.expectStr('[')) != null
                            &&
                            (b = this.slices()) != null
                            &&
                            (literal_1 = this.expectStr(']')) != null
                            &&
                            this.negative_lookahead(this::t_lookahead)
            ) {
                return ast.Subscript ( a , b , ast.Store() , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T star_atom;
            if (
                    (star_atom = this.star_atom()) != null
            ) {
                return star_atom;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> star_atom_cache = new HashMap<>();

    protected T star_atom() {
        int p = this.mark();
        Memo<T> info = star_atom_cache.get(p);
        if (info != null) {
            log("star_atom() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("star_atom() ...");
        this._level += 1;
        T result = _star_atom();
        this._level -= 1;
        log("star_atom() [fresh]-> ", result);
        if (result != null) {
            star_atom_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _star_atom() {
        // star_atom: NAME | '(' star_target ')' | '(' star_targets_seq? ')' | '[' star_targets_seq? ']'
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            if (
                    (a = this.name()) != null
            ) {
                return ast.set_expr_context ( a , ast.Store() );
            }
            this.reset(mark);
        }
        {
            Token literal;
            T a;
            Token literal_1;
            if (
                    (literal = this.expectStr('(')) != null
                            &&
                            (a = this.star_target()) != null
                            &&
                            (literal_1 = this.expectStr(')')) != null
            ) {
                return ast.set_expr_context ( a , ast.Store() );
            }
            this.reset(mark);
        }
        {
            Token literal;
            T[] a;
            Token literal_1;
            if (
                    (literal = this.expectStr('(')) != null
                            &&
                            ((a = this.star_targets_seq()) != null || true)
                            &&
                            (literal_1 = this.expectStr(')')) != null
            ) {
                return ast.Tuple ( a , ast.Store() , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            Token literal;
            T[] a;
            Token literal_1;
            if (
                    (literal = this.expectStr('[')) != null
                            &&
                            ((a = this.star_targets_seq()) != null || true)
                            &&
                            (literal_1 = this.expectStr(']')) != null
            ) {
                return ast.List ( a , ast.Store() , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> single_target_cache = new HashMap<>();

    protected T single_target() {
        int p = this.mark();
        Memo<T> info = single_target_cache.get(p);
        if (info != null) {
            log("single_target() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("single_target() ...");
        this._level += 1;
        T result = _single_target();
        this._level -= 1;
        log("single_target() [fresh]-> ", result);
        if (result != null) {
            single_target_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _single_target() {
        // single_target: single_subscript_attribute_target | NAME | '(' single_target ')'
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T single_subscript_attribute_target;
            if (
                    (single_subscript_attribute_target = this.single_subscript_attribute_target()) != null
            ) {
                return single_subscript_attribute_target;
            }
            this.reset(mark);
        }
        {
            T a;
            if (
                    (a = this.name()) != null
            ) {
                return ast.set_expr_context ( a , ast.Store() );
            }
            this.reset(mark);
        }
        {
            Token literal;
            T a;
            Token literal_1;
            if (
                    (literal = this.expectStr('(')) != null
                            &&
                            (a = this.single_target()) != null
                            &&
                            (literal_1 = this.expectStr(')')) != null
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> single_subscript_attribute_target_cache = new HashMap<>();

    protected T single_subscript_attribute_target() {
        int p = this.mark();
        Memo<T> info = single_subscript_attribute_target_cache.get(p);
        if (info != null) {
            log("single_subscript_attribute_target() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("single_subscript_attribute_target() ...");
        this._level += 1;
        T result = _single_subscript_attribute_target();
        this._level -= 1;
        log("single_subscript_attribute_target() [fresh]-> ", result);
        if (result != null) {
            single_subscript_attribute_target_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _single_subscript_attribute_target() {
        // single_subscript_attribute_target: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.t_primary()) != null
                            &&
                            (literal = this.expectStr('.')) != null
                            &&
                            (b = this.name()) != null
                            &&
                            this.negative_lookahead(this::t_lookahead)
            ) {
                return ast.Attribute ( a , ast.get_expr_name(b) , ast.Store() , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            Token literal;
            T b;
            Token literal_1;
            if (
                    (a = this.t_primary()) != null
                            &&
                            (literal = this.expectStr('[')) != null
                            &&
                            (b = this.slices()) != null
                            &&
                            (literal_1 = this.expectStr(']')) != null
                            &&
                            this.negative_lookahead(this::t_lookahead)
            ) {
                return ast.Subscript ( a , b , ast.Store() , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> del_targets_cache = new HashMap<>();

    protected T[] del_targets() {
        int p = this.mark();
        Memo<T[]> info = del_targets_cache.get(p);
        if (info != null) {
            log("del_targets() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("del_targets() ...");
        this._level += 1;
        T[] result = _del_targets();
        this._level -= 1;
        log("del_targets() [fresh]-> ", result);
        if (result != null) {
            del_targets_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _del_targets() {
        // del_targets: ','.del_target+ ','?
        // type: asdl_expr_seq*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            Token literal;
            if (
                    (a = this._gather_122()) != null
                            &&
                            ((literal = this.expectStr(',')) != null || true)
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> del_target_cache = new HashMap<>();

    protected T del_target() {
        int p = this.mark();
        Memo<T> info = del_target_cache.get(p);
        if (info != null) {
            log("del_target() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("del_target() ...");
        this._level += 1;
        T result = _del_target();
        this._level -= 1;
        log("del_target() [fresh]-> ", result);
        if (result != null) {
            del_target_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _del_target() {
        // del_target: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead | del_t_atom
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.t_primary()) != null
                            &&
                            (literal = this.expectStr('.')) != null
                            &&
                            (b = this.name()) != null
                            &&
                            this.negative_lookahead(this::t_lookahead)
            ) {
                return ast.Attribute ( a , ast.get_expr_name(b) , ast.Del() , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            Token literal;
            T b;
            Token literal_1;
            if (
                    (a = this.t_primary()) != null
                            &&
                            (literal = this.expectStr('[')) != null
                            &&
                            (b = this.slices()) != null
                            &&
                            (literal_1 = this.expectStr(']')) != null
                            &&
                            this.negative_lookahead(this::t_lookahead)
            ) {
                return ast.Subscript ( a , b , ast.Del() , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T del_t_atom;
            if (
                    (del_t_atom = this.del_t_atom()) != null
            ) {
                return del_t_atom;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> del_t_atom_cache = new HashMap<>();

    protected T del_t_atom() {
        int p = this.mark();
        Memo<T> info = del_t_atom_cache.get(p);
        if (info != null) {
            log("del_t_atom() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("del_t_atom() ...");
        this._level += 1;
        T result = _del_t_atom();
        this._level -= 1;
        log("del_t_atom() [fresh]-> ", result);
        if (result != null) {
            del_t_atom_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _del_t_atom() {
        // del_t_atom: NAME | '(' del_target ')' | '(' del_targets? ')' | '[' del_targets? ']'
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            if (
                    (a = this.name()) != null
            ) {
                return ast.set_expr_context ( a , ast.Del() );
            }
            this.reset(mark);
        }
        {
            Token literal;
            T a;
            Token literal_1;
            if (
                    (literal = this.expectStr('(')) != null
                            &&
                            (a = this.del_target()) != null
                            &&
                            (literal_1 = this.expectStr(')')) != null
            ) {
                return ast.set_expr_context ( a , ast.Del() );
            }
            this.reset(mark);
        }
        {
            Token literal;
            T[] a;
            Token literal_1;
            if (
                    (literal = this.expectStr('(')) != null
                            &&
                            ((a = this.del_targets()) != null || true)
                            &&
                            (literal_1 = this.expectStr(')')) != null
            ) {
                return ast.Tuple ( a , ast.Del() , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            Token literal;
            T[] a;
            Token literal_1;
            if (
                    (literal = this.expectStr('[')) != null
                            &&
                            ((a = this.del_targets()) != null || true)
                            &&
                            (literal_1 = this.expectStr(']')) != null
            ) {
                return ast.List ( a , ast.Del() , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> targets_cache = new HashMap<>();

    protected T[] targets() {
        int p = this.mark();
        Memo<T[]> info = targets_cache.get(p);
        if (info != null) {
            log("targets() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("targets() ...");
        this._level += 1;
        T[] result = _targets();
        this._level -= 1;
        log("targets() [fresh]-> ", result);
        if (result != null) {
            targets_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _targets() {
        // targets: ','.target+ ','?
        // type: asdl_expr_seq*
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            Token literal;
            if (
                    (a = this._gather_124()) != null
                            &&
                            ((literal = this.expectStr(',')) != null || true)
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> target_cache = new HashMap<>();

    protected T target() {
        int p = this.mark();
        Memo<T> info = target_cache.get(p);
        if (info != null) {
            log("target() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("target() ...");
        this._level += 1;
        T result = _target();
        this._level -= 1;
        log("target() [fresh]-> ", result);
        if (result != null) {
            target_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _target() {
        // target: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead | t_atom
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.t_primary()) != null
                            &&
                            (literal = this.expectStr('.')) != null
                            &&
                            (b = this.name()) != null
                            &&
                            this.negative_lookahead(this::t_lookahead)
            ) {
                return ast.Attribute ( a , ast.get_expr_name(b) , ast.Store() , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            Token literal;
            T b;
            Token literal_1;
            if (
                    (a = this.t_primary()) != null
                            &&
                            (literal = this.expectStr('[')) != null
                            &&
                            (b = this.slices()) != null
                            &&
                            (literal_1 = this.expectStr(']')) != null
                            &&
                            this.negative_lookahead(this::t_lookahead)
            ) {
                return ast.Subscript ( a , b , ast.Store() , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T t_atom;
            if (
                    (t_atom = this.t_atom()) != null
            ) {
                return t_atom;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> t_primary_cache = new HashMap<>();

    protected T t_primary() {
        int p = this.mark();
        Memo<T> info = t_primary_cache.get(p);
        if (info != null) {
            log("t_primary() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("t_primary() ...");
        T last_result = null;
        int last_mark = p;
        int depth = 0;
        t_primary_cache.put(p, new Memo<>(null, p));
        log("recursive t_primary() at " + p + " depth " + depth);
        while (true) {
            this.reset(p);
            this._level += 1;
            T result = _t_primary();
            int end_mark = this.mark();
            depth += 1;
            this._level -= 1;
            log("recursive t_primary() at " + p + " depth " + depth + ": ", result);
            if (result == null || end_mark <= last_mark)
                break;
            last_result = result;
            last_mark = end_mark;
            t_primary_cache.put(p, new Memo<>(result, end_mark));
        }
        this.reset(last_mark);
        if (last_result != null) {
            last_mark = this.mark();
        } else {
            last_mark = p;
            this.reset(last_mark);
        }
        log("t_primary() [fresh]-> ", last_result);
        t_primary_cache.put(p, new Memo<>(last_result, last_mark));
        return last_result;
    }

    private T _t_primary() {
        // t_primary: t_primary '.' NAME &t_lookahead | t_primary '[' slices ']' &t_lookahead | t_primary genexp &t_lookahead | t_primary '(' arguments? ')' &t_lookahead | atom &t_lookahead
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            Token literal;
            T b;
            if (
                    (a = this.t_primary()) != null
                            &&
                            (literal = this.expectStr('.')) != null
                            &&
                            (b = this.name()) != null
                            &&
                            this.positive_lookahead(this::t_lookahead)
            ) {
                return ast.Attribute ( a , ast.get_expr_name(b) , ast.Load() , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            Token literal;
            T b;
            Token literal_1;
            if (
                    (a = this.t_primary()) != null
                            &&
                            (literal = this.expectStr('[')) != null
                            &&
                            (b = this.slices()) != null
                            &&
                            (literal_1 = this.expectStr(']')) != null
                            &&
                            this.positive_lookahead(this::t_lookahead)
            ) {
                return ast.Subscript ( a , b , ast.Load() , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            T b;
            if (
                    (a = this.t_primary()) != null
                            &&
                            (b = this.genexp()) != null
                            &&
                            this.positive_lookahead(this::t_lookahead)
            ) {
                return ast.Call ( a , ast.singleton_seq ( b ) , null , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            Token literal;
            T b;
            Token literal_1;
            if (
                    (a = this.t_primary()) != null
                            &&
                            (literal = this.expectStr('(')) != null
                            &&
                            ((b = this.arguments()) != null || true)
                            &&
                            (literal_1 = this.expectStr(')')) != null
                            &&
                            this.positive_lookahead(this::t_lookahead)
            ) {
                return ast.Call ( a , (b != null) ? ast.get_call_args(b) : null , (b != null) ? ast.get_call_keywords(b) : null , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            T a;
            if (
                    (a = this.atom()) != null
                            &&
                            this.positive_lookahead(this::t_lookahead)
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> t_lookahead_cache = new HashMap<>();

    protected T t_lookahead() {
        int p = this.mark();
        Memo<T> info = t_lookahead_cache.get(p);
        if (info != null) {
            log("t_lookahead() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("t_lookahead() ...");
        this._level += 1;
        T result = _t_lookahead();
        this._level -= 1;
        log("t_lookahead() [fresh]-> ", result);
        if (result != null) {
            t_lookahead_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _t_lookahead() {
        // t_lookahead: '(' | '[' | '.'
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            if (
                    (literal = this.expectStr('(')) != null
            ) {
                return ast.from_token(literal);
            }
            this.reset(mark);
        }
        {
            Token literal;
            if (
                    (literal = this.expectStr('[')) != null
            ) {
                return ast.from_token(literal);
            }
            this.reset(mark);
        }
        {
            Token literal;
            if (
                    (literal = this.expectStr('.')) != null
            ) {
                return ast.from_token(literal);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> t_atom_cache = new HashMap<>();

    protected T t_atom() {
        int p = this.mark();
        Memo<T> info = t_atom_cache.get(p);
        if (info != null) {
            log("t_atom() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("t_atom() ...");
        this._level += 1;
        T result = _t_atom();
        this._level -= 1;
        log("t_atom() [fresh]-> ", result);
        if (result != null) {
            t_atom_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T _t_atom() {
        // t_atom: NAME | '(' target ')' | '(' targets? ')' | '[' targets? ']'
        // type: expr_ty
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            if (
                    (a = this.name()) != null
            ) {
                return ast.set_expr_context ( a , ast.Store() );
            }
            this.reset(mark);
        }
        {
            Token literal;
            T a;
            Token literal_1;
            if (
                    (literal = this.expectStr('(')) != null
                            &&
                            (a = this.target()) != null
                            &&
                            (literal_1 = this.expectStr(')')) != null
            ) {
                return ast.set_expr_context ( a , ast.Store() );
            }
            this.reset(mark);
        }
        {
            Token literal;
            T[] b;
            Token literal_1;
            if (
                    (literal = this.expectStr('(')) != null
                            &&
                            ((b = this.targets()) != null || true)
                            &&
                            (literal_1 = this.expectStr(')')) != null
            ) {
                return ast.Tuple ( b , ast.Store() , line_no , col_offset );
            }
            this.reset(mark);
        }
        {
            Token literal;
            T[] b;
            Token literal_1;
            if (
                    (literal = this.expectStr('[')) != null
                            &&
                            ((b = this.targets()) != null || true)
                            &&
                            (literal_1 = this.expectStr(']')) != null
            ) {
                return ast.List ( b , ast.Store() , line_no , col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop0_1_cache = new HashMap<>();

    protected T[] _loop0_1() {
        int p = this.mark();
        Memo<T[]> info = _loop0_1_cache.get(p);
        if (info != null) {
            log("_loop0_1() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_1() ...");
        this._level += 1;
        T[] result = __loop0_1();
        this._level -= 1;
        log("_loop0_1() [fresh]-> ", result);
        if (result != null) {
            _loop0_1_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_1() {
        // _loop0_1: NEWLINE
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            while (
                    this.expect(TokenType.NEWLINE) != null
            ) {
                children.add(ast.None());
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_2_cache = new HashMap<>();

    protected T[] _loop0_2() {
        int p = this.mark();
        Memo<T[]> info = _loop0_2_cache.get(p);
        if (info != null) {
            log("_loop0_2() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_2() ...");
        this._level += 1;
        T[] result = __loop0_2();
        this._level -= 1;
        log("_loop0_2() [fresh]-> ", result);
        if (result != null) {
            _loop0_2_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_2() {
        // _loop0_2: NEWLINE
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            while (
                    this.expect(TokenType.NEWLINE) != null
            ) {
                children.add(ast.None());
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_4_cache = new HashMap<>();

    protected T[] _loop0_4() {
        int p = this.mark();
        Memo<T[]> info = _loop0_4_cache.get(p);
        if (info != null) {
            log("_loop0_4() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_4() ...");
        this._level += 1;
        T[] result = __loop0_4();
        this._level -= 1;
        log("_loop0_4() [fresh]-> ", result);
        if (result != null) {
            _loop0_4_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_4() {
        // _loop0_4: ',' expression
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.expression()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_3_cache = new HashMap<>();

    protected T[] _gather_3() {
        int p = this.mark();
        Memo<T[]> info = _gather_3_cache.get(p);
        if (info != null) {
            log("_gather_3() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_3() ...");
        this._level += 1;
        T[] result = __gather_3();
        this._level -= 1;
        log("_gather_3() [fresh]-> ", result);
        if (result != null) {
            _gather_3_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_3() {
        // _gather_3: expression _loop0_4
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.expression()) != null
                            &&
                            (seq = this._loop0_4()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop0_6_cache = new HashMap<>();

    protected T[] _loop0_6() {
        int p = this.mark();
        Memo<T[]> info = _loop0_6_cache.get(p);
        if (info != null) {
            log("_loop0_6() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_6() ...");
        this._level += 1;
        T[] result = __loop0_6();
        this._level -= 1;
        log("_loop0_6() [fresh]-> ", result);
        if (result != null) {
            _loop0_6_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_6() {
        // _loop0_6: ',' expression
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.expression()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_5_cache = new HashMap<>();

    protected T[] _gather_5() {
        int p = this.mark();
        Memo<T[]> info = _gather_5_cache.get(p);
        if (info != null) {
            log("_gather_5() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_5() ...");
        this._level += 1;
        T[] result = __gather_5();
        this._level -= 1;
        log("_gather_5() [fresh]-> ", result);
        if (result != null) {
            _gather_5_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_5() {
        // _gather_5: expression _loop0_6
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.expression()) != null
                            &&
                            (seq = this._loop0_6()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop0_8_cache = new HashMap<>();

    protected T[] _loop0_8() {
        int p = this.mark();
        Memo<T[]> info = _loop0_8_cache.get(p);
        if (info != null) {
            log("_loop0_8() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_8() ...");
        this._level += 1;
        T[] result = __loop0_8();
        this._level -= 1;
        log("_loop0_8() [fresh]-> ", result);
        if (result != null) {
            _loop0_8_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_8() {
        // _loop0_8: ',' expression
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.expression()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_7_cache = new HashMap<>();

    protected T[] _gather_7() {
        int p = this.mark();
        Memo<T[]> info = _gather_7_cache.get(p);
        if (info != null) {
            log("_gather_7() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_7() ...");
        this._level += 1;
        T[] result = __gather_7();
        this._level -= 1;
        log("_gather_7() [fresh]-> ", result);
        if (result != null) {
            _gather_7_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_7() {
        // _gather_7: expression _loop0_8
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.expression()) != null
                            &&
                            (seq = this._loop0_8()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop0_10_cache = new HashMap<>();

    protected T[] _loop0_10() {
        int p = this.mark();
        Memo<T[]> info = _loop0_10_cache.get(p);
        if (info != null) {
            log("_loop0_10() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_10() ...");
        this._level += 1;
        T[] result = __loop0_10();
        this._level -= 1;
        log("_loop0_10() [fresh]-> ", result);
        if (result != null) {
            _loop0_10_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_10() {
        // _loop0_10: ',' expression
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.expression()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_9_cache = new HashMap<>();

    protected T[] _gather_9() {
        int p = this.mark();
        Memo<T[]> info = _gather_9_cache.get(p);
        if (info != null) {
            log("_gather_9() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_9() ...");
        this._level += 1;
        T[] result = __gather_9();
        this._level -= 1;
        log("_gather_9() [fresh]-> ", result);
        if (result != null) {
            _gather_9_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_9() {
        // _gather_9: expression _loop0_10
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.expression()) != null
                            &&
                            (seq = this._loop0_10()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop1_11_cache = new HashMap<>();

    protected T[] _loop1_11() {
        int p = this.mark();
        Memo<T[]> info = _loop1_11_cache.get(p);
        if (info != null) {
            log("_loop1_11() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_11() ...");
        this._level += 1;
        T[] result = __loop1_11();
        this._level -= 1;
        log("_loop1_11() [fresh]-> ", result);
        if (result != null) {
            _loop1_11_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_11() {
        // _loop1_11: statement
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T[] statement;
            while (
                    (statement = this.statement()) != null
            ) {
                children.addAll(Arrays.asList(statement));
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_13_cache = new HashMap<>();

    protected T[] _loop0_13() {
        int p = this.mark();
        Memo<T[]> info = _loop0_13_cache.get(p);
        if (info != null) {
            log("_loop0_13() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_13() ...");
        this._level += 1;
        T[] result = __loop0_13();
        this._level -= 1;
        log("_loop0_13() [fresh]-> ", result);
        if (result != null) {
            _loop0_13_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_13() {
        // _loop0_13: ';' small_stmt
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(';')) != null
                            &&
                            (elem = this.small_stmt()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_12_cache = new HashMap<>();

    protected T[] _gather_12() {
        int p = this.mark();
        Memo<T[]> info = _gather_12_cache.get(p);
        if (info != null) {
            log("_gather_12() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_12() ...");
        this._level += 1;
        T[] result = __gather_12();
        this._level -= 1;
        log("_gather_12() [fresh]-> ", result);
        if (result != null) {
            _gather_12_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_12() {
        // _gather_12: small_stmt _loop0_13
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.small_stmt()) != null
                            &&
                            (seq = this._loop0_13()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_14_cache = new HashMap<>();

    protected T _tmp_14() {
        int p = this.mark();
        Memo<T> info = _tmp_14_cache.get(p);
        if (info != null) {
            log("_tmp_14() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_14() ...");
        this._level += 1;
        T result = __tmp_14();
        this._level -= 1;
        log("_tmp_14() [fresh]-> ", result);
        if (result != null) {
            _tmp_14_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_14() {
        // _tmp_14: 'import' | 'from'
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            if (
                    this.expectKeyword("import") != null
            ) {
                return ast.None();
            }
            this.reset(mark);
        }
        {
            if (
                    this.expectKeyword("from") != null
            ) {
                return ast.None();
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_15_cache = new HashMap<>();

    protected T _tmp_15() {
        int p = this.mark();
        Memo<T> info = _tmp_15_cache.get(p);
        if (info != null) {
            log("_tmp_15() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_15() ...");
        this._level += 1;
        T result = __tmp_15();
        this._level -= 1;
        log("_tmp_15() [fresh]-> ", result);
        if (result != null) {
            _tmp_15_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_15() {
        // _tmp_15: 'def' | '@' | ASYNC
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            if (
                    this.expectKeyword("def") != null
            ) {
                return ast.None();
            }
            this.reset(mark);
        }
        {
            Token literal;
            if (
                    (literal = this.expectStr('@')) != null
            ) {
                return ast.from_token(literal);
            }
            this.reset(mark);
        }
        {
            if (
                    this.expect(TokenType.ASYNC) != null
            ) {
                return ast.None();
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_16_cache = new HashMap<>();

    protected T _tmp_16() {
        int p = this.mark();
        Memo<T> info = _tmp_16_cache.get(p);
        if (info != null) {
            log("_tmp_16() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_16() ...");
        this._level += 1;
        T result = __tmp_16();
        this._level -= 1;
        log("_tmp_16() [fresh]-> ", result);
        if (result != null) {
            _tmp_16_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_16() {
        // _tmp_16: 'class' | '@'
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            if (
                    this.expectKeyword("class") != null
            ) {
                return ast.None();
            }
            this.reset(mark);
        }
        {
            Token literal;
            if (
                    (literal = this.expectStr('@')) != null
            ) {
                return ast.from_token(literal);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_17_cache = new HashMap<>();

    protected T _tmp_17() {
        int p = this.mark();
        Memo<T> info = _tmp_17_cache.get(p);
        if (info != null) {
            log("_tmp_17() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_17() ...");
        this._level += 1;
        T result = __tmp_17();
        this._level -= 1;
        log("_tmp_17() [fresh]-> ", result);
        if (result != null) {
            _tmp_17_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_17() {
        // _tmp_17: 'with' | ASYNC
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            if (
                    this.expectKeyword("with") != null
            ) {
                return ast.None();
            }
            this.reset(mark);
        }
        {
            if (
                    this.expect(TokenType.ASYNC) != null
            ) {
                return ast.None();
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_18_cache = new HashMap<>();

    protected T _tmp_18() {
        int p = this.mark();
        Memo<T> info = _tmp_18_cache.get(p);
        if (info != null) {
            log("_tmp_18() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_18() ...");
        this._level += 1;
        T result = __tmp_18();
        this._level -= 1;
        log("_tmp_18() [fresh]-> ", result);
        if (result != null) {
            _tmp_18_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_18() {
        // _tmp_18: 'for' | ASYNC
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            if (
                    this.expectKeyword("for") != null
            ) {
                return ast.None();
            }
            this.reset(mark);
        }
        {
            if (
                    this.expect(TokenType.ASYNC) != null
            ) {
                return ast.None();
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_19_cache = new HashMap<>();

    protected T _tmp_19() {
        int p = this.mark();
        Memo<T> info = _tmp_19_cache.get(p);
        if (info != null) {
            log("_tmp_19() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_19() ...");
        this._level += 1;
        T result = __tmp_19();
        this._level -= 1;
        log("_tmp_19() [fresh]-> ", result);
        if (result != null) {
            _tmp_19_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_19() {
        // _tmp_19: '=' annotated_rhs
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T d;
            if (
                    (literal = this.expectStr('=')) != null
                            &&
                            (d = this.annotated_rhs()) != null
            ) {
                return d;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_20_cache = new HashMap<>();

    protected T _tmp_20() {
        int p = this.mark();
        Memo<T> info = _tmp_20_cache.get(p);
        if (info != null) {
            log("_tmp_20() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_20() ...");
        this._level += 1;
        T result = __tmp_20();
        this._level -= 1;
        log("_tmp_20() [fresh]-> ", result);
        if (result != null) {
            _tmp_20_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_20() {
        // _tmp_20: '(' single_target ')' | single_subscript_attribute_target
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T b;
            Token literal_1;
            if (
                    (literal = this.expectStr('(')) != null
                            &&
                            (b = this.single_target()) != null
                            &&
                            (literal_1 = this.expectStr(')')) != null
            ) {
                return b;
            }
            this.reset(mark);
        }
        {
            T single_subscript_attribute_target;
            if (
                    (single_subscript_attribute_target = this.single_subscript_attribute_target()) != null
            ) {
                return single_subscript_attribute_target;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_21_cache = new HashMap<>();

    protected T _tmp_21() {
        int p = this.mark();
        Memo<T> info = _tmp_21_cache.get(p);
        if (info != null) {
            log("_tmp_21() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_21() ...");
        this._level += 1;
        T result = __tmp_21();
        this._level -= 1;
        log("_tmp_21() [fresh]-> ", result);
        if (result != null) {
            _tmp_21_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_21() {
        // _tmp_21: '=' annotated_rhs
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T d;
            if (
                    (literal = this.expectStr('=')) != null
                            &&
                            (d = this.annotated_rhs()) != null
            ) {
                return d;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop1_22_cache = new HashMap<>();

    protected T[] _loop1_22() {
        int p = this.mark();
        Memo<T[]> info = _loop1_22_cache.get(p);
        if (info != null) {
            log("_loop1_22() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_22() ...");
        this._level += 1;
        T[] result = __loop1_22();
        this._level -= 1;
        log("_loop1_22() [fresh]-> ", result);
        if (result != null) {
            _loop1_22_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_22() {
        // _loop1_22: (star_targets '=')
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T _tmp_126;
            while (
                    (_tmp_126 = this._tmp_126()) != null
            ) {
                children.add(_tmp_126);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T>> _tmp_23_cache = new HashMap<>();

    protected T _tmp_23() {
        int p = this.mark();
        Memo<T> info = _tmp_23_cache.get(p);
        if (info != null) {
            log("_tmp_23() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_23() ...");
        this._level += 1;
        T result = __tmp_23();
        this._level -= 1;
        log("_tmp_23() [fresh]-> ", result);
        if (result != null) {
            _tmp_23_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_23() {
        // _tmp_23: yield_expr | star_expressions
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T yield_expr;
            if (
                    (yield_expr = this.yield_expr()) != null
            ) {
                return yield_expr;
            }
            this.reset(mark);
        }
        {
            T star_expressions;
            if (
                    (star_expressions = this.star_expressions()) != null
            ) {
                return star_expressions;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_24_cache = new HashMap<>();

    protected T _tmp_24() {
        int p = this.mark();
        Memo<T> info = _tmp_24_cache.get(p);
        if (info != null) {
            log("_tmp_24() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_24() ...");
        this._level += 1;
        T result = __tmp_24();
        this._level -= 1;
        log("_tmp_24() [fresh]-> ", result);
        if (result != null) {
            _tmp_24_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_24() {
        // _tmp_24: yield_expr | star_expressions
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T yield_expr;
            if (
                    (yield_expr = this.yield_expr()) != null
            ) {
                return yield_expr;
            }
            this.reset(mark);
        }
        {
            T star_expressions;
            if (
                    (star_expressions = this.star_expressions()) != null
            ) {
                return star_expressions;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop0_26_cache = new HashMap<>();

    protected T[] _loop0_26() {
        int p = this.mark();
        Memo<T[]> info = _loop0_26_cache.get(p);
        if (info != null) {
            log("_loop0_26() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_26() ...");
        this._level += 1;
        T[] result = __loop0_26();
        this._level -= 1;
        log("_loop0_26() [fresh]-> ", result);
        if (result != null) {
            _loop0_26_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_26() {
        // _loop0_26: ',' NAME
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.name()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_25_cache = new HashMap<>();

    protected T[] _gather_25() {
        int p = this.mark();
        Memo<T[]> info = _gather_25_cache.get(p);
        if (info != null) {
            log("_gather_25() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_25() ...");
        this._level += 1;
        T[] result = __gather_25();
        this._level -= 1;
        log("_gather_25() [fresh]-> ", result);
        if (result != null) {
            _gather_25_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_25() {
        // _gather_25: NAME _loop0_26
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.name()) != null
                            &&
                            (seq = this._loop0_26()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop0_28_cache = new HashMap<>();

    protected T[] _loop0_28() {
        int p = this.mark();
        Memo<T[]> info = _loop0_28_cache.get(p);
        if (info != null) {
            log("_loop0_28() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_28() ...");
        this._level += 1;
        T[] result = __loop0_28();
        this._level -= 1;
        log("_loop0_28() [fresh]-> ", result);
        if (result != null) {
            _loop0_28_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_28() {
        // _loop0_28: ',' NAME
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.name()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_27_cache = new HashMap<>();

    protected T[] _gather_27() {
        int p = this.mark();
        Memo<T[]> info = _gather_27_cache.get(p);
        if (info != null) {
            log("_gather_27() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_27() ...");
        this._level += 1;
        T[] result = __gather_27();
        this._level -= 1;
        log("_gather_27() [fresh]-> ", result);
        if (result != null) {
            _gather_27_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_27() {
        // _gather_27: NAME _loop0_28
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.name()) != null
                            &&
                            (seq = this._loop0_28()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_29_cache = new HashMap<>();

    protected T _tmp_29() {
        int p = this.mark();
        Memo<T> info = _tmp_29_cache.get(p);
        if (info != null) {
            log("_tmp_29() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_29() ...");
        this._level += 1;
        T result = __tmp_29();
        this._level -= 1;
        log("_tmp_29() [fresh]-> ", result);
        if (result != null) {
            _tmp_29_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_29() {
        // _tmp_29: ',' expression
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T z;
            if (
                    (literal = this.expectStr(',')) != null
                            &&
                            (z = this.expression()) != null
            ) {
                return z;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_30_cache = new HashMap<>();

    protected T _tmp_30() {
        int p = this.mark();
        Memo<T> info = _tmp_30_cache.get(p);
        if (info != null) {
            log("_tmp_30() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_30() ...");
        this._level += 1;
        T result = __tmp_30();
        this._level -= 1;
        log("_tmp_30() [fresh]-> ", result);
        if (result != null) {
            _tmp_30_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_30() {
        // _tmp_30: ';' | NEWLINE
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            if (
                    (literal = this.expectStr(';')) != null
            ) {
                return ast.from_token(literal);
            }
            this.reset(mark);
        }
        {
            if (
                    this.expect(TokenType.NEWLINE) != null
            ) {
                return ast.None();
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop0_31_cache = new HashMap<>();

    protected T[] _loop0_31() {
        int p = this.mark();
        Memo<T[]> info = _loop0_31_cache.get(p);
        if (info != null) {
            log("_loop0_31() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_31() ...");
        this._level += 1;
        T[] result = __loop0_31();
        this._level -= 1;
        log("_loop0_31() [fresh]-> ", result);
        if (result != null) {
            _loop0_31_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_31() {
        // _loop0_31: ('.' | '...')
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T _tmp_127;
            while (
                    (_tmp_127 = this._tmp_127()) != null
            ) {
                children.add(_tmp_127);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop1_32_cache = new HashMap<>();

    protected T[] _loop1_32() {
        int p = this.mark();
        Memo<T[]> info = _loop1_32_cache.get(p);
        if (info != null) {
            log("_loop1_32() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_32() ...");
        this._level += 1;
        T[] result = __loop1_32();
        this._level -= 1;
        log("_loop1_32() [fresh]-> ", result);
        if (result != null) {
            _loop1_32_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_32() {
        // _loop1_32: ('.' | '...')
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T _tmp_128;
            while (
                    (_tmp_128 = this._tmp_128()) != null
            ) {
                children.add(_tmp_128);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_34_cache = new HashMap<>();

    protected T[] _loop0_34() {
        int p = this.mark();
        Memo<T[]> info = _loop0_34_cache.get(p);
        if (info != null) {
            log("_loop0_34() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_34() ...");
        this._level += 1;
        T[] result = __loop0_34();
        this._level -= 1;
        log("_loop0_34() [fresh]-> ", result);
        if (result != null) {
            _loop0_34_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_34() {
        // _loop0_34: ',' import_from_as_name
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.import_from_as_name()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_33_cache = new HashMap<>();

    protected T[] _gather_33() {
        int p = this.mark();
        Memo<T[]> info = _gather_33_cache.get(p);
        if (info != null) {
            log("_gather_33() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_33() ...");
        this._level += 1;
        T[] result = __gather_33();
        this._level -= 1;
        log("_gather_33() [fresh]-> ", result);
        if (result != null) {
            _gather_33_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_33() {
        // _gather_33: import_from_as_name _loop0_34
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.import_from_as_name()) != null
                            &&
                            (seq = this._loop0_34()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_35_cache = new HashMap<>();

    protected T _tmp_35() {
        int p = this.mark();
        Memo<T> info = _tmp_35_cache.get(p);
        if (info != null) {
            log("_tmp_35() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_35() ...");
        this._level += 1;
        T result = __tmp_35();
        this._level -= 1;
        log("_tmp_35() [fresh]-> ", result);
        if (result != null) {
            _tmp_35_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_35() {
        // _tmp_35: 'as' NAME
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T z;
            if (
                    this.expectKeyword("as") != null
                            &&
                            (z = this.name()) != null
            ) {
                return z;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop0_37_cache = new HashMap<>();

    protected T[] _loop0_37() {
        int p = this.mark();
        Memo<T[]> info = _loop0_37_cache.get(p);
        if (info != null) {
            log("_loop0_37() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_37() ...");
        this._level += 1;
        T[] result = __loop0_37();
        this._level -= 1;
        log("_loop0_37() [fresh]-> ", result);
        if (result != null) {
            _loop0_37_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_37() {
        // _loop0_37: ',' dotted_as_name
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.dotted_as_name()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_36_cache = new HashMap<>();

    protected T[] _gather_36() {
        int p = this.mark();
        Memo<T[]> info = _gather_36_cache.get(p);
        if (info != null) {
            log("_gather_36() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_36() ...");
        this._level += 1;
        T[] result = __gather_36();
        this._level -= 1;
        log("_gather_36() [fresh]-> ", result);
        if (result != null) {
            _gather_36_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_36() {
        // _gather_36: dotted_as_name _loop0_37
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.dotted_as_name()) != null
                            &&
                            (seq = this._loop0_37()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_38_cache = new HashMap<>();

    protected T _tmp_38() {
        int p = this.mark();
        Memo<T> info = _tmp_38_cache.get(p);
        if (info != null) {
            log("_tmp_38() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_38() ...");
        this._level += 1;
        T result = __tmp_38();
        this._level -= 1;
        log("_tmp_38() [fresh]-> ", result);
        if (result != null) {
            _tmp_38_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_38() {
        // _tmp_38: 'as' NAME
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T z;
            if (
                    this.expectKeyword("as") != null
                            &&
                            (z = this.name()) != null
            ) {
                return z;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop0_40_cache = new HashMap<>();

    protected T[] _loop0_40() {
        int p = this.mark();
        Memo<T[]> info = _loop0_40_cache.get(p);
        if (info != null) {
            log("_loop0_40() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_40() ...");
        this._level += 1;
        T[] result = __loop0_40();
        this._level -= 1;
        log("_loop0_40() [fresh]-> ", result);
        if (result != null) {
            _loop0_40_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_40() {
        // _loop0_40: ',' with_item
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.with_item()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_39_cache = new HashMap<>();

    protected T[] _gather_39() {
        int p = this.mark();
        Memo<T[]> info = _gather_39_cache.get(p);
        if (info != null) {
            log("_gather_39() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_39() ...");
        this._level += 1;
        T[] result = __gather_39();
        this._level -= 1;
        log("_gather_39() [fresh]-> ", result);
        if (result != null) {
            _gather_39_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_39() {
        // _gather_39: with_item _loop0_40
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.with_item()) != null
                            &&
                            (seq = this._loop0_40()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop0_42_cache = new HashMap<>();

    protected T[] _loop0_42() {
        int p = this.mark();
        Memo<T[]> info = _loop0_42_cache.get(p);
        if (info != null) {
            log("_loop0_42() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_42() ...");
        this._level += 1;
        T[] result = __loop0_42();
        this._level -= 1;
        log("_loop0_42() [fresh]-> ", result);
        if (result != null) {
            _loop0_42_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_42() {
        // _loop0_42: ',' with_item
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.with_item()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_41_cache = new HashMap<>();

    protected T[] _gather_41() {
        int p = this.mark();
        Memo<T[]> info = _gather_41_cache.get(p);
        if (info != null) {
            log("_gather_41() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_41() ...");
        this._level += 1;
        T[] result = __gather_41();
        this._level -= 1;
        log("_gather_41() [fresh]-> ", result);
        if (result != null) {
            _gather_41_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_41() {
        // _gather_41: with_item _loop0_42
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.with_item()) != null
                            &&
                            (seq = this._loop0_42()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop0_44_cache = new HashMap<>();

    protected T[] _loop0_44() {
        int p = this.mark();
        Memo<T[]> info = _loop0_44_cache.get(p);
        if (info != null) {
            log("_loop0_44() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_44() ...");
        this._level += 1;
        T[] result = __loop0_44();
        this._level -= 1;
        log("_loop0_44() [fresh]-> ", result);
        if (result != null) {
            _loop0_44_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_44() {
        // _loop0_44: ',' with_item
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.with_item()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_43_cache = new HashMap<>();

    protected T[] _gather_43() {
        int p = this.mark();
        Memo<T[]> info = _gather_43_cache.get(p);
        if (info != null) {
            log("_gather_43() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_43() ...");
        this._level += 1;
        T[] result = __gather_43();
        this._level -= 1;
        log("_gather_43() [fresh]-> ", result);
        if (result != null) {
            _gather_43_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_43() {
        // _gather_43: with_item _loop0_44
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.with_item()) != null
                            &&
                            (seq = this._loop0_44()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop0_46_cache = new HashMap<>();

    protected T[] _loop0_46() {
        int p = this.mark();
        Memo<T[]> info = _loop0_46_cache.get(p);
        if (info != null) {
            log("_loop0_46() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_46() ...");
        this._level += 1;
        T[] result = __loop0_46();
        this._level -= 1;
        log("_loop0_46() [fresh]-> ", result);
        if (result != null) {
            _loop0_46_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_46() {
        // _loop0_46: ',' with_item
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.with_item()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_45_cache = new HashMap<>();

    protected T[] _gather_45() {
        int p = this.mark();
        Memo<T[]> info = _gather_45_cache.get(p);
        if (info != null) {
            log("_gather_45() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_45() ...");
        this._level += 1;
        T[] result = __gather_45();
        this._level -= 1;
        log("_gather_45() [fresh]-> ", result);
        if (result != null) {
            _gather_45_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_45() {
        // _gather_45: with_item _loop0_46
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.with_item()) != null
                            &&
                            (seq = this._loop0_46()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_47_cache = new HashMap<>();

    protected T _tmp_47() {
        int p = this.mark();
        Memo<T> info = _tmp_47_cache.get(p);
        if (info != null) {
            log("_tmp_47() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_47() ...");
        this._level += 1;
        T result = __tmp_47();
        this._level -= 1;
        log("_tmp_47() [fresh]-> ", result);
        if (result != null) {
            _tmp_47_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_47() {
        // _tmp_47: ',' | ')' | ':'
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            if (
                    (literal = this.expectStr(',')) != null
            ) {
                return ast.from_token(literal);
            }
            this.reset(mark);
        }
        {
            Token literal;
            if (
                    (literal = this.expectStr(')')) != null
            ) {
                return ast.from_token(literal);
            }
            this.reset(mark);
        }
        {
            Token literal;
            if (
                    (literal = this.expectStr(':')) != null
            ) {
                return ast.from_token(literal);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop1_48_cache = new HashMap<>();

    protected T[] _loop1_48() {
        int p = this.mark();
        Memo<T[]> info = _loop1_48_cache.get(p);
        if (info != null) {
            log("_loop1_48() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_48() ...");
        this._level += 1;
        T[] result = __loop1_48();
        this._level -= 1;
        log("_loop1_48() [fresh]-> ", result);
        if (result != null) {
            _loop1_48_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_48() {
        // _loop1_48: except_block
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T except_block;
            while (
                    (except_block = this.except_block()) != null
            ) {
                children.add(except_block);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T>> _tmp_49_cache = new HashMap<>();

    protected T _tmp_49() {
        int p = this.mark();
        Memo<T> info = _tmp_49_cache.get(p);
        if (info != null) {
            log("_tmp_49() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_49() ...");
        this._level += 1;
        T result = __tmp_49();
        this._level -= 1;
        log("_tmp_49() [fresh]-> ", result);
        if (result != null) {
            _tmp_49_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_49() {
        // _tmp_49: 'as' NAME
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T z;
            if (
                    this.expectKeyword("as") != null
                            &&
                            (z = this.name()) != null
            ) {
                return z;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_50_cache = new HashMap<>();

    protected T _tmp_50() {
        int p = this.mark();
        Memo<T> info = _tmp_50_cache.get(p);
        if (info != null) {
            log("_tmp_50() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_50() ...");
        this._level += 1;
        T result = __tmp_50();
        this._level -= 1;
        log("_tmp_50() [fresh]-> ", result);
        if (result != null) {
            _tmp_50_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_50() {
        // _tmp_50: 'from' expression
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T z;
            if (
                    this.expectKeyword("from") != null
                            &&
                            (z = this.expression()) != null
            ) {
                return z;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_51_cache = new HashMap<>();

    protected T _tmp_51() {
        int p = this.mark();
        Memo<T> info = _tmp_51_cache.get(p);
        if (info != null) {
            log("_tmp_51() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_51() ...");
        this._level += 1;
        T result = __tmp_51();
        this._level -= 1;
        log("_tmp_51() [fresh]-> ", result);
        if (result != null) {
            _tmp_51_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_51() {
        // _tmp_51: '->' expression
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T z;
            if (
                    (literal = this.expectStr("->")) != null
                            &&
                            (z = this.expression()) != null
            ) {
                return z;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_52_cache = new HashMap<>();

    protected T _tmp_52() {
        int p = this.mark();
        Memo<T> info = _tmp_52_cache.get(p);
        if (info != null) {
            log("_tmp_52() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_52() ...");
        this._level += 1;
        T result = __tmp_52();
        this._level -= 1;
        log("_tmp_52() [fresh]-> ", result);
        if (result != null) {
            _tmp_52_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_52() {
        // _tmp_52: '->' expression
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T z;
            if (
                    (literal = this.expectStr("->")) != null
                            &&
                            (z = this.expression()) != null
            ) {
                return z;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_53_cache = new HashMap<>();

    protected T _tmp_53() {
        int p = this.mark();
        Memo<T> info = _tmp_53_cache.get(p);
        if (info != null) {
            log("_tmp_53() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_53() ...");
        this._level += 1;
        T result = __tmp_53();
        this._level -= 1;
        log("_tmp_53() [fresh]-> ", result);
        if (result != null) {
            _tmp_53_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_53() {
        // _tmp_53: NEWLINE INDENT
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            if (
                    this.expect(TokenType.NEWLINE) != null
                            &&
                            this.expect(TokenType.INDENT) != null
            ) {
                return ast.None();
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop0_54_cache = new HashMap<>();

    protected T[] _loop0_54() {
        int p = this.mark();
        Memo<T[]> info = _loop0_54_cache.get(p);
        if (info != null) {
            log("_loop0_54() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_54() ...");
        this._level += 1;
        T[] result = __loop0_54();
        this._level -= 1;
        log("_loop0_54() [fresh]-> ", result);
        if (result != null) {
            _loop0_54_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_54() {
        // _loop0_54: param_no_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T param_no_default;
            while (
                    (param_no_default = this.param_no_default()) != null
            ) {
                children.add(param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_55_cache = new HashMap<>();

    protected T[] _loop0_55() {
        int p = this.mark();
        Memo<T[]> info = _loop0_55_cache.get(p);
        if (info != null) {
            log("_loop0_55() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_55() ...");
        this._level += 1;
        T[] result = __loop0_55();
        this._level -= 1;
        log("_loop0_55() [fresh]-> ", result);
        if (result != null) {
            _loop0_55_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_55() {
        // _loop0_55: param_with_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T param_with_default;
            while (
                    (param_with_default = this.param_with_default()) != null
            ) {
                children.add(param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_56_cache = new HashMap<>();

    protected T[] _loop0_56() {
        int p = this.mark();
        Memo<T[]> info = _loop0_56_cache.get(p);
        if (info != null) {
            log("_loop0_56() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_56() ...");
        this._level += 1;
        T[] result = __loop0_56();
        this._level -= 1;
        log("_loop0_56() [fresh]-> ", result);
        if (result != null) {
            _loop0_56_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_56() {
        // _loop0_56: param_with_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T param_with_default;
            while (
                    (param_with_default = this.param_with_default()) != null
            ) {
                children.add(param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop1_57_cache = new HashMap<>();

    protected T[] _loop1_57() {
        int p = this.mark();
        Memo<T[]> info = _loop1_57_cache.get(p);
        if (info != null) {
            log("_loop1_57() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_57() ...");
        this._level += 1;
        T[] result = __loop1_57();
        this._level -= 1;
        log("_loop1_57() [fresh]-> ", result);
        if (result != null) {
            _loop1_57_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_57() {
        // _loop1_57: param_no_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T param_no_default;
            while (
                    (param_no_default = this.param_no_default()) != null
            ) {
                children.add(param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_58_cache = new HashMap<>();

    protected T[] _loop0_58() {
        int p = this.mark();
        Memo<T[]> info = _loop0_58_cache.get(p);
        if (info != null) {
            log("_loop0_58() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_58() ...");
        this._level += 1;
        T[] result = __loop0_58();
        this._level -= 1;
        log("_loop0_58() [fresh]-> ", result);
        if (result != null) {
            _loop0_58_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_58() {
        // _loop0_58: param_with_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T param_with_default;
            while (
                    (param_with_default = this.param_with_default()) != null
            ) {
                children.add(param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop1_59_cache = new HashMap<>();

    protected T[] _loop1_59() {
        int p = this.mark();
        Memo<T[]> info = _loop1_59_cache.get(p);
        if (info != null) {
            log("_loop1_59() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_59() ...");
        this._level += 1;
        T[] result = __loop1_59();
        this._level -= 1;
        log("_loop1_59() [fresh]-> ", result);
        if (result != null) {
            _loop1_59_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_59() {
        // _loop1_59: param_with_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T param_with_default;
            while (
                    (param_with_default = this.param_with_default()) != null
            ) {
                children.add(param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop1_60_cache = new HashMap<>();

    protected T[] _loop1_60() {
        int p = this.mark();
        Memo<T[]> info = _loop1_60_cache.get(p);
        if (info != null) {
            log("_loop1_60() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_60() ...");
        this._level += 1;
        T[] result = __loop1_60();
        this._level -= 1;
        log("_loop1_60() [fresh]-> ", result);
        if (result != null) {
            _loop1_60_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_60() {
        // _loop1_60: param_no_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T param_no_default;
            while (
                    (param_no_default = this.param_no_default()) != null
            ) {
                children.add(param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop1_61_cache = new HashMap<>();

    protected T[] _loop1_61() {
        int p = this.mark();
        Memo<T[]> info = _loop1_61_cache.get(p);
        if (info != null) {
            log("_loop1_61() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_61() ...");
        this._level += 1;
        T[] result = __loop1_61();
        this._level -= 1;
        log("_loop1_61() [fresh]-> ", result);
        if (result != null) {
            _loop1_61_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_61() {
        // _loop1_61: param_no_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T param_no_default;
            while (
                    (param_no_default = this.param_no_default()) != null
            ) {
                children.add(param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_62_cache = new HashMap<>();

    protected T[] _loop0_62() {
        int p = this.mark();
        Memo<T[]> info = _loop0_62_cache.get(p);
        if (info != null) {
            log("_loop0_62() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_62() ...");
        this._level += 1;
        T[] result = __loop0_62();
        this._level -= 1;
        log("_loop0_62() [fresh]-> ", result);
        if (result != null) {
            _loop0_62_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_62() {
        // _loop0_62: param_no_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T param_no_default;
            while (
                    (param_no_default = this.param_no_default()) != null
            ) {
                children.add(param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop1_63_cache = new HashMap<>();

    protected T[] _loop1_63() {
        int p = this.mark();
        Memo<T[]> info = _loop1_63_cache.get(p);
        if (info != null) {
            log("_loop1_63() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_63() ...");
        this._level += 1;
        T[] result = __loop1_63();
        this._level -= 1;
        log("_loop1_63() [fresh]-> ", result);
        if (result != null) {
            _loop1_63_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_63() {
        // _loop1_63: param_with_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T param_with_default;
            while (
                    (param_with_default = this.param_with_default()) != null
            ) {
                children.add(param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_64_cache = new HashMap<>();

    protected T[] _loop0_64() {
        int p = this.mark();
        Memo<T[]> info = _loop0_64_cache.get(p);
        if (info != null) {
            log("_loop0_64() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_64() ...");
        this._level += 1;
        T[] result = __loop0_64();
        this._level -= 1;
        log("_loop0_64() [fresh]-> ", result);
        if (result != null) {
            _loop0_64_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_64() {
        // _loop0_64: param_no_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T param_no_default;
            while (
                    (param_no_default = this.param_no_default()) != null
            ) {
                children.add(param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop1_65_cache = new HashMap<>();

    protected T[] _loop1_65() {
        int p = this.mark();
        Memo<T[]> info = _loop1_65_cache.get(p);
        if (info != null) {
            log("_loop1_65() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_65() ...");
        this._level += 1;
        T[] result = __loop1_65();
        this._level -= 1;
        log("_loop1_65() [fresh]-> ", result);
        if (result != null) {
            _loop1_65_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_65() {
        // _loop1_65: param_with_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T param_with_default;
            while (
                    (param_with_default = this.param_with_default()) != null
            ) {
                children.add(param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_66_cache = new HashMap<>();

    protected T[] _loop0_66() {
        int p = this.mark();
        Memo<T[]> info = _loop0_66_cache.get(p);
        if (info != null) {
            log("_loop0_66() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_66() ...");
        this._level += 1;
        T[] result = __loop0_66();
        this._level -= 1;
        log("_loop0_66() [fresh]-> ", result);
        if (result != null) {
            _loop0_66_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_66() {
        // _loop0_66: param_maybe_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T param_maybe_default;
            while (
                    (param_maybe_default = this.param_maybe_default()) != null
            ) {
                children.add(param_maybe_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop1_67_cache = new HashMap<>();

    protected T[] _loop1_67() {
        int p = this.mark();
        Memo<T[]> info = _loop1_67_cache.get(p);
        if (info != null) {
            log("_loop1_67() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_67() ...");
        this._level += 1;
        T[] result = __loop1_67();
        this._level -= 1;
        log("_loop1_67() [fresh]-> ", result);
        if (result != null) {
            _loop1_67_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_67() {
        // _loop1_67: param_maybe_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T param_maybe_default;
            while (
                    (param_maybe_default = this.param_maybe_default()) != null
            ) {
                children.add(param_maybe_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop1_68_cache = new HashMap<>();

    protected T[] _loop1_68() {
        int p = this.mark();
        Memo<T[]> info = _loop1_68_cache.get(p);
        if (info != null) {
            log("_loop1_68() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_68() ...");
        this._level += 1;
        T[] result = __loop1_68();
        this._level -= 1;
        log("_loop1_68() [fresh]-> ", result);
        if (result != null) {
            _loop1_68_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_68() {
        // _loop1_68: ('@' named_expression NEWLINE)
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T _tmp_129;
            while (
                    (_tmp_129 = this._tmp_129()) != null
            ) {
                children.add(_tmp_129);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T>> _tmp_69_cache = new HashMap<>();

    protected T _tmp_69() {
        int p = this.mark();
        Memo<T> info = _tmp_69_cache.get(p);
        if (info != null) {
            log("_tmp_69() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_69() ...");
        this._level += 1;
        T result = __tmp_69();
        this._level -= 1;
        log("_tmp_69() [fresh]-> ", result);
        if (result != null) {
            _tmp_69_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_69() {
        // _tmp_69: '(' arguments? ')'
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T z;
            Token literal_1;
            if (
                    (literal = this.expectStr('(')) != null
                            &&
                            ((z = this.arguments()) != null || true)
                            &&
                            (literal_1 = this.expectStr(')')) != null
            ) {
                return z;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop0_71_cache = new HashMap<>();

    protected T[] _loop0_71() {
        int p = this.mark();
        Memo<T[]> info = _loop0_71_cache.get(p);
        if (info != null) {
            log("_loop0_71() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_71() ...");
        this._level += 1;
        T[] result = __loop0_71();
        this._level -= 1;
        log("_loop0_71() [fresh]-> ", result);
        if (result != null) {
            _loop0_71_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_71() {
        // _loop0_71: ',' star_expression
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.star_expression()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_70_cache = new HashMap<>();

    protected T[] _gather_70() {
        int p = this.mark();
        Memo<T[]> info = _gather_70_cache.get(p);
        if (info != null) {
            log("_gather_70() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_70() ...");
        this._level += 1;
        T[] result = __gather_70();
        this._level -= 1;
        log("_gather_70() [fresh]-> ", result);
        if (result != null) {
            _gather_70_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_70() {
        // _gather_70: star_expression _loop0_71
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.star_expression()) != null
                            &&
                            (seq = this._loop0_71()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop1_72_cache = new HashMap<>();

    protected T[] _loop1_72() {
        int p = this.mark();
        Memo<T[]> info = _loop1_72_cache.get(p);
        if (info != null) {
            log("_loop1_72() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_72() ...");
        this._level += 1;
        T[] result = __loop1_72();
        this._level -= 1;
        log("_loop1_72() [fresh]-> ", result);
        if (result != null) {
            _loop1_72_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_72() {
        // _loop1_72: (',' star_expression)
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T _tmp_130;
            while (
                    (_tmp_130 = this._tmp_130()) != null
            ) {
                children.add(_tmp_130);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_74_cache = new HashMap<>();

    protected T[] _loop0_74() {
        int p = this.mark();
        Memo<T[]> info = _loop0_74_cache.get(p);
        if (info != null) {
            log("_loop0_74() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_74() ...");
        this._level += 1;
        T[] result = __loop0_74();
        this._level -= 1;
        log("_loop0_74() [fresh]-> ", result);
        if (result != null) {
            _loop0_74_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_74() {
        // _loop0_74: ',' star_named_expression
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.star_named_expression()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_73_cache = new HashMap<>();

    protected T[] _gather_73() {
        int p = this.mark();
        Memo<T[]> info = _gather_73_cache.get(p);
        if (info != null) {
            log("_gather_73() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_73() ...");
        this._level += 1;
        T[] result = __gather_73();
        this._level -= 1;
        log("_gather_73() [fresh]-> ", result);
        if (result != null) {
            _gather_73_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_73() {
        // _gather_73: star_named_expression _loop0_74
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.star_named_expression()) != null
                            &&
                            (seq = this._loop0_74()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop1_75_cache = new HashMap<>();

    protected T[] _loop1_75() {
        int p = this.mark();
        Memo<T[]> info = _loop1_75_cache.get(p);
        if (info != null) {
            log("_loop1_75() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_75() ...");
        this._level += 1;
        T[] result = __loop1_75();
        this._level -= 1;
        log("_loop1_75() [fresh]-> ", result);
        if (result != null) {
            _loop1_75_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_75() {
        // _loop1_75: (',' expression)
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T _tmp_131;
            while (
                    (_tmp_131 = this._tmp_131()) != null
            ) {
                children.add(_tmp_131);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_76_cache = new HashMap<>();

    protected T[] _loop0_76() {
        int p = this.mark();
        Memo<T[]> info = _loop0_76_cache.get(p);
        if (info != null) {
            log("_loop0_76() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_76() ...");
        this._level += 1;
        T[] result = __loop0_76();
        this._level -= 1;
        log("_loop0_76() [fresh]-> ", result);
        if (result != null) {
            _loop0_76_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_76() {
        // _loop0_76: lambda_param_no_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T lambda_param_no_default;
            while (
                    (lambda_param_no_default = this.lambda_param_no_default()) != null
            ) {
                children.add(lambda_param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_77_cache = new HashMap<>();

    protected T[] _loop0_77() {
        int p = this.mark();
        Memo<T[]> info = _loop0_77_cache.get(p);
        if (info != null) {
            log("_loop0_77() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_77() ...");
        this._level += 1;
        T[] result = __loop0_77();
        this._level -= 1;
        log("_loop0_77() [fresh]-> ", result);
        if (result != null) {
            _loop0_77_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_77() {
        // _loop0_77: lambda_param_with_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T lambda_param_with_default;
            while (
                    (lambda_param_with_default = this.lambda_param_with_default()) != null
            ) {
                children.add(lambda_param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_78_cache = new HashMap<>();

    protected T[] _loop0_78() {
        int p = this.mark();
        Memo<T[]> info = _loop0_78_cache.get(p);
        if (info != null) {
            log("_loop0_78() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_78() ...");
        this._level += 1;
        T[] result = __loop0_78();
        this._level -= 1;
        log("_loop0_78() [fresh]-> ", result);
        if (result != null) {
            _loop0_78_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_78() {
        // _loop0_78: lambda_param_with_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T lambda_param_with_default;
            while (
                    (lambda_param_with_default = this.lambda_param_with_default()) != null
            ) {
                children.add(lambda_param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop1_79_cache = new HashMap<>();

    protected T[] _loop1_79() {
        int p = this.mark();
        Memo<T[]> info = _loop1_79_cache.get(p);
        if (info != null) {
            log("_loop1_79() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_79() ...");
        this._level += 1;
        T[] result = __loop1_79();
        this._level -= 1;
        log("_loop1_79() [fresh]-> ", result);
        if (result != null) {
            _loop1_79_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_79() {
        // _loop1_79: lambda_param_no_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T lambda_param_no_default;
            while (
                    (lambda_param_no_default = this.lambda_param_no_default()) != null
            ) {
                children.add(lambda_param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_80_cache = new HashMap<>();

    protected T[] _loop0_80() {
        int p = this.mark();
        Memo<T[]> info = _loop0_80_cache.get(p);
        if (info != null) {
            log("_loop0_80() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_80() ...");
        this._level += 1;
        T[] result = __loop0_80();
        this._level -= 1;
        log("_loop0_80() [fresh]-> ", result);
        if (result != null) {
            _loop0_80_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_80() {
        // _loop0_80: lambda_param_with_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T lambda_param_with_default;
            while (
                    (lambda_param_with_default = this.lambda_param_with_default()) != null
            ) {
                children.add(lambda_param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop1_81_cache = new HashMap<>();

    protected T[] _loop1_81() {
        int p = this.mark();
        Memo<T[]> info = _loop1_81_cache.get(p);
        if (info != null) {
            log("_loop1_81() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_81() ...");
        this._level += 1;
        T[] result = __loop1_81();
        this._level -= 1;
        log("_loop1_81() [fresh]-> ", result);
        if (result != null) {
            _loop1_81_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_81() {
        // _loop1_81: lambda_param_with_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T lambda_param_with_default;
            while (
                    (lambda_param_with_default = this.lambda_param_with_default()) != null
            ) {
                children.add(lambda_param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop1_82_cache = new HashMap<>();

    protected T[] _loop1_82() {
        int p = this.mark();
        Memo<T[]> info = _loop1_82_cache.get(p);
        if (info != null) {
            log("_loop1_82() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_82() ...");
        this._level += 1;
        T[] result = __loop1_82();
        this._level -= 1;
        log("_loop1_82() [fresh]-> ", result);
        if (result != null) {
            _loop1_82_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_82() {
        // _loop1_82: lambda_param_no_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T lambda_param_no_default;
            while (
                    (lambda_param_no_default = this.lambda_param_no_default()) != null
            ) {
                children.add(lambda_param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop1_83_cache = new HashMap<>();

    protected T[] _loop1_83() {
        int p = this.mark();
        Memo<T[]> info = _loop1_83_cache.get(p);
        if (info != null) {
            log("_loop1_83() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_83() ...");
        this._level += 1;
        T[] result = __loop1_83();
        this._level -= 1;
        log("_loop1_83() [fresh]-> ", result);
        if (result != null) {
            _loop1_83_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_83() {
        // _loop1_83: lambda_param_no_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T lambda_param_no_default;
            while (
                    (lambda_param_no_default = this.lambda_param_no_default()) != null
            ) {
                children.add(lambda_param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_84_cache = new HashMap<>();

    protected T[] _loop0_84() {
        int p = this.mark();
        Memo<T[]> info = _loop0_84_cache.get(p);
        if (info != null) {
            log("_loop0_84() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_84() ...");
        this._level += 1;
        T[] result = __loop0_84();
        this._level -= 1;
        log("_loop0_84() [fresh]-> ", result);
        if (result != null) {
            _loop0_84_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_84() {
        // _loop0_84: lambda_param_no_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T lambda_param_no_default;
            while (
                    (lambda_param_no_default = this.lambda_param_no_default()) != null
            ) {
                children.add(lambda_param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop1_85_cache = new HashMap<>();

    protected T[] _loop1_85() {
        int p = this.mark();
        Memo<T[]> info = _loop1_85_cache.get(p);
        if (info != null) {
            log("_loop1_85() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_85() ...");
        this._level += 1;
        T[] result = __loop1_85();
        this._level -= 1;
        log("_loop1_85() [fresh]-> ", result);
        if (result != null) {
            _loop1_85_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_85() {
        // _loop1_85: lambda_param_with_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T lambda_param_with_default;
            while (
                    (lambda_param_with_default = this.lambda_param_with_default()) != null
            ) {
                children.add(lambda_param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_86_cache = new HashMap<>();

    protected T[] _loop0_86() {
        int p = this.mark();
        Memo<T[]> info = _loop0_86_cache.get(p);
        if (info != null) {
            log("_loop0_86() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_86() ...");
        this._level += 1;
        T[] result = __loop0_86();
        this._level -= 1;
        log("_loop0_86() [fresh]-> ", result);
        if (result != null) {
            _loop0_86_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_86() {
        // _loop0_86: lambda_param_no_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T lambda_param_no_default;
            while (
                    (lambda_param_no_default = this.lambda_param_no_default()) != null
            ) {
                children.add(lambda_param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop1_87_cache = new HashMap<>();

    protected T[] _loop1_87() {
        int p = this.mark();
        Memo<T[]> info = _loop1_87_cache.get(p);
        if (info != null) {
            log("_loop1_87() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_87() ...");
        this._level += 1;
        T[] result = __loop1_87();
        this._level -= 1;
        log("_loop1_87() [fresh]-> ", result);
        if (result != null) {
            _loop1_87_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_87() {
        // _loop1_87: lambda_param_with_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T lambda_param_with_default;
            while (
                    (lambda_param_with_default = this.lambda_param_with_default()) != null
            ) {
                children.add(lambda_param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_88_cache = new HashMap<>();

    protected T[] _loop0_88() {
        int p = this.mark();
        Memo<T[]> info = _loop0_88_cache.get(p);
        if (info != null) {
            log("_loop0_88() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_88() ...");
        this._level += 1;
        T[] result = __loop0_88();
        this._level -= 1;
        log("_loop0_88() [fresh]-> ", result);
        if (result != null) {
            _loop0_88_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_88() {
        // _loop0_88: lambda_param_maybe_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T lambda_param_maybe_default;
            while (
                    (lambda_param_maybe_default = this.lambda_param_maybe_default()) != null
            ) {
                children.add(lambda_param_maybe_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop1_89_cache = new HashMap<>();

    protected T[] _loop1_89() {
        int p = this.mark();
        Memo<T[]> info = _loop1_89_cache.get(p);
        if (info != null) {
            log("_loop1_89() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_89() ...");
        this._level += 1;
        T[] result = __loop1_89();
        this._level -= 1;
        log("_loop1_89() [fresh]-> ", result);
        if (result != null) {
            _loop1_89_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_89() {
        // _loop1_89: lambda_param_maybe_default
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T lambda_param_maybe_default;
            while (
                    (lambda_param_maybe_default = this.lambda_param_maybe_default()) != null
            ) {
                children.add(lambda_param_maybe_default);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop1_90_cache = new HashMap<>();

    protected T[] _loop1_90() {
        int p = this.mark();
        Memo<T[]> info = _loop1_90_cache.get(p);
        if (info != null) {
            log("_loop1_90() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_90() ...");
        this._level += 1;
        T[] result = __loop1_90();
        this._level -= 1;
        log("_loop1_90() [fresh]-> ", result);
        if (result != null) {
            _loop1_90_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_90() {
        // _loop1_90: ('or' conjunction)
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T _tmp_132;
            while (
                    (_tmp_132 = this._tmp_132()) != null
            ) {
                children.add(_tmp_132);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop1_91_cache = new HashMap<>();

    protected T[] _loop1_91() {
        int p = this.mark();
        Memo<T[]> info = _loop1_91_cache.get(p);
        if (info != null) {
            log("_loop1_91() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_91() ...");
        this._level += 1;
        T[] result = __loop1_91();
        this._level -= 1;
        log("_loop1_91() [fresh]-> ", result);
        if (result != null) {
            _loop1_91_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_91() {
        // _loop1_91: ('and' inversion)
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T _tmp_133;
            while (
                    (_tmp_133 = this._tmp_133()) != null
            ) {
                children.add(_tmp_133);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop1_92_cache = new HashMap<>();

    protected T[] _loop1_92() {
        int p = this.mark();
        Memo<T[]> info = _loop1_92_cache.get(p);
        if (info != null) {
            log("_loop1_92() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_92() ...");
        this._level += 1;
        T[] result = __loop1_92();
        this._level -= 1;
        log("_loop1_92() [fresh]-> ", result);
        if (result != null) {
            _loop1_92_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_92() {
        // _loop1_92: compare_op_bitwise_or_pair
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T compare_op_bitwise_or_pair;
            while (
                    (compare_op_bitwise_or_pair = this.compare_op_bitwise_or_pair()) != null
            ) {
                children.add(compare_op_bitwise_or_pair);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_94_cache = new HashMap<>();

    protected T[] _loop0_94() {
        int p = this.mark();
        Memo<T[]> info = _loop0_94_cache.get(p);
        if (info != null) {
            log("_loop0_94() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_94() ...");
        this._level += 1;
        T[] result = __loop0_94();
        this._level -= 1;
        log("_loop0_94() [fresh]-> ", result);
        if (result != null) {
            _loop0_94_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_94() {
        // _loop0_94: ',' slice
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.slice()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_93_cache = new HashMap<>();

    protected T[] _gather_93() {
        int p = this.mark();
        Memo<T[]> info = _gather_93_cache.get(p);
        if (info != null) {
            log("_gather_93() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_93() ...");
        this._level += 1;
        T[] result = __gather_93();
        this._level -= 1;
        log("_gather_93() [fresh]-> ", result);
        if (result != null) {
            _gather_93_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_93() {
        // _gather_93: slice _loop0_94
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.slice()) != null
                            &&
                            (seq = this._loop0_94()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_95_cache = new HashMap<>();

    protected T _tmp_95() {
        int p = this.mark();
        Memo<T> info = _tmp_95_cache.get(p);
        if (info != null) {
            log("_tmp_95() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_95() ...");
        this._level += 1;
        T result = __tmp_95();
        this._level -= 1;
        log("_tmp_95() [fresh]-> ", result);
        if (result != null) {
            _tmp_95_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_95() {
        // _tmp_95: ':' expression?
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T d;
            if (
                    (literal = this.expectStr(':')) != null
                            &&
                            ((d = this.expression()) != null || true)
            ) {
                return d;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_96_cache = new HashMap<>();

    protected T _tmp_96() {
        int p = this.mark();
        Memo<T> info = _tmp_96_cache.get(p);
        if (info != null) {
            log("_tmp_96() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_96() ...");
        this._level += 1;
        T result = __tmp_96();
        this._level -= 1;
        log("_tmp_96() [fresh]-> ", result);
        if (result != null) {
            _tmp_96_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_96() {
        // _tmp_96: tuple | group | genexp
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T tuple;
            if (
                    (tuple = this.tuple()) != null
            ) {
                return tuple;
            }
            this.reset(mark);
        }
        {
            T group;
            if (
                    (group = this.group()) != null
            ) {
                return group;
            }
            this.reset(mark);
        }
        {
            T genexp;
            if (
                    (genexp = this.genexp()) != null
            ) {
                return genexp;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_97_cache = new HashMap<>();

    protected T _tmp_97() {
        int p = this.mark();
        Memo<T> info = _tmp_97_cache.get(p);
        if (info != null) {
            log("_tmp_97() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_97() ...");
        this._level += 1;
        T result = __tmp_97();
        this._level -= 1;
        log("_tmp_97() [fresh]-> ", result);
        if (result != null) {
            _tmp_97_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_97() {
        // _tmp_97: list | listcomp
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T list;
            if (
                    (list = this.list()) != null
            ) {
                return list;
            }
            this.reset(mark);
        }
        {
            T listcomp;
            if (
                    (listcomp = this.listcomp()) != null
            ) {
                return listcomp;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_98_cache = new HashMap<>();

    protected T _tmp_98() {
        int p = this.mark();
        Memo<T> info = _tmp_98_cache.get(p);
        if (info != null) {
            log("_tmp_98() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_98() ...");
        this._level += 1;
        T result = __tmp_98();
        this._level -= 1;
        log("_tmp_98() [fresh]-> ", result);
        if (result != null) {
            _tmp_98_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_98() {
        // _tmp_98: dict | set | dictcomp | setcomp
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T dict;
            if (
                    (dict = this.dict()) != null
            ) {
                return dict;
            }
            this.reset(mark);
        }
        {
            T set;
            if (
                    (set = this.set()) != null
            ) {
                return set;
            }
            this.reset(mark);
        }
        {
            T dictcomp;
            if (
                    (dictcomp = this.dictcomp()) != null
            ) {
                return dictcomp;
            }
            this.reset(mark);
        }
        {
            T setcomp;
            if (
                    (setcomp = this.setcomp()) != null
            ) {
                return setcomp;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop1_99_cache = new HashMap<>();

    protected T[] _loop1_99() {
        int p = this.mark();
        Memo<T[]> info = _loop1_99_cache.get(p);
        if (info != null) {
            log("_loop1_99() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_99() ...");
        this._level += 1;
        T[] result = __loop1_99();
        this._level -= 1;
        log("_loop1_99() [fresh]-> ", result);
        if (result != null) {
            _loop1_99_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_99() {
        // _loop1_99: STRING
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token string;
            while (
                    (string = this.string()) != null
            ) {
                children.add(ast.from_token(string));
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _tmp_100_cache = new HashMap<>();

    protected T[] _tmp_100() {
        int p = this.mark();
        Memo<T[]> info = _tmp_100_cache.get(p);
        if (info != null) {
            log("_tmp_100() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_100() ...");
        this._level += 1;
        T[] result = __tmp_100();
        this._level -= 1;
        log("_tmp_100() [fresh]-> ", result);
        if (result != null) {
            _tmp_100_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __tmp_100() {
        // _tmp_100: star_named_expression ',' star_named_expressions?
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T y;
            Token literal;
            T[] z;
            if (
                    (y = this.star_named_expression()) != null
                            &&
                            (literal = this.expectStr(',')) != null
                            &&
                            ((z = this.star_named_expressions()) != null || true)
            ) {
                return ast.seq_insert_in_front ( y , z );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_101_cache = new HashMap<>();

    protected T _tmp_101() {
        int p = this.mark();
        Memo<T> info = _tmp_101_cache.get(p);
        if (info != null) {
            log("_tmp_101() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_101() ...");
        this._level += 1;
        T result = __tmp_101();
        this._level -= 1;
        log("_tmp_101() [fresh]-> ", result);
        if (result != null) {
            _tmp_101_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_101() {
        // _tmp_101: yield_expr | named_expression
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T yield_expr;
            if (
                    (yield_expr = this.yield_expr()) != null
            ) {
                return yield_expr;
            }
            this.reset(mark);
        }
        {
            T named_expression;
            if (
                    (named_expression = this.named_expression()) != null
            ) {
                return named_expression;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop0_103_cache = new HashMap<>();

    protected T[] _loop0_103() {
        int p = this.mark();
        Memo<T[]> info = _loop0_103_cache.get(p);
        if (info != null) {
            log("_loop0_103() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_103() ...");
        this._level += 1;
        T[] result = __loop0_103();
        this._level -= 1;
        log("_loop0_103() [fresh]-> ", result);
        if (result != null) {
            _loop0_103_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_103() {
        // _loop0_103: ',' double_starred_kvpair
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.double_starred_kvpair()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_102_cache = new HashMap<>();

    protected T[] _gather_102() {
        int p = this.mark();
        Memo<T[]> info = _gather_102_cache.get(p);
        if (info != null) {
            log("_gather_102() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_102() ...");
        this._level += 1;
        T[] result = __gather_102();
        this._level -= 1;
        log("_gather_102() [fresh]-> ", result);
        if (result != null) {
            _gather_102_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_102() {
        // _gather_102: double_starred_kvpair _loop0_103
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.double_starred_kvpair()) != null
                            &&
                            (seq = this._loop0_103()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop1_104_cache = new HashMap<>();

    protected T[] _loop1_104() {
        int p = this.mark();
        Memo<T[]> info = _loop1_104_cache.get(p);
        if (info != null) {
            log("_loop1_104() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_104() ...");
        this._level += 1;
        T[] result = __loop1_104();
        this._level -= 1;
        log("_loop1_104() [fresh]-> ", result);
        if (result != null) {
            _loop1_104_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_104() {
        // _loop1_104: for_if_clause
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T for_if_clause;
            while (
                    (for_if_clause = this.for_if_clause()) != null
            ) {
                children.add(for_if_clause);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_105_cache = new HashMap<>();

    protected T[] _loop0_105() {
        int p = this.mark();
        Memo<T[]> info = _loop0_105_cache.get(p);
        if (info != null) {
            log("_loop0_105() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_105() ...");
        this._level += 1;
        T[] result = __loop0_105();
        this._level -= 1;
        log("_loop0_105() [fresh]-> ", result);
        if (result != null) {
            _loop0_105_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_105() {
        // _loop0_105: ('if' disjunction)
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T _tmp_134;
            while (
                    (_tmp_134 = this._tmp_134()) != null
            ) {
                children.add(_tmp_134);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_106_cache = new HashMap<>();

    protected T[] _loop0_106() {
        int p = this.mark();
        Memo<T[]> info = _loop0_106_cache.get(p);
        if (info != null) {
            log("_loop0_106() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_106() ...");
        this._level += 1;
        T[] result = __loop0_106();
        this._level -= 1;
        log("_loop0_106() [fresh]-> ", result);
        if (result != null) {
            _loop0_106_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_106() {
        // _loop0_106: ('if' disjunction)
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T _tmp_135;
            while (
                    (_tmp_135 = this._tmp_135()) != null
            ) {
                children.add(_tmp_135);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_108_cache = new HashMap<>();

    protected T[] _loop0_108() {
        int p = this.mark();
        Memo<T[]> info = _loop0_108_cache.get(p);
        if (info != null) {
            log("_loop0_108() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_108() ...");
        this._level += 1;
        T[] result = __loop0_108();
        this._level -= 1;
        log("_loop0_108() [fresh]-> ", result);
        if (result != null) {
            _loop0_108_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_108() {
        // _loop0_108: ',' (starred_expression | named_expression !'=')
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this._tmp_136()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_107_cache = new HashMap<>();

    protected T[] _gather_107() {
        int p = this.mark();
        Memo<T[]> info = _gather_107_cache.get(p);
        if (info != null) {
            log("_gather_107() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_107() ...");
        this._level += 1;
        T[] result = __gather_107();
        this._level -= 1;
        log("_gather_107() [fresh]-> ", result);
        if (result != null) {
            _gather_107_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_107() {
        // _gather_107: (starred_expression | named_expression !'=') _loop0_108
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this._tmp_136()) != null
                            &&
                            (seq = this._loop0_108()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _tmp_109_cache = new HashMap<>();

    protected T[] _tmp_109() {
        int p = this.mark();
        Memo<T[]> info = _tmp_109_cache.get(p);
        if (info != null) {
            log("_tmp_109() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_109() ...");
        this._level += 1;
        T[] result = __tmp_109();
        this._level -= 1;
        log("_tmp_109() [fresh]-> ", result);
        if (result != null) {
            _tmp_109_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __tmp_109() {
        // _tmp_109: ',' kwargs
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T[] k;
            if (
                    (literal = this.expectStr(',')) != null
                            &&
                            (k = this.kwargs()) != null
            ) {
                return k;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop0_111_cache = new HashMap<>();

    protected T[] _loop0_111() {
        int p = this.mark();
        Memo<T[]> info = _loop0_111_cache.get(p);
        if (info != null) {
            log("_loop0_111() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_111() ...");
        this._level += 1;
        T[] result = __loop0_111();
        this._level -= 1;
        log("_loop0_111() [fresh]-> ", result);
        if (result != null) {
            _loop0_111_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_111() {
        // _loop0_111: ',' kwarg_or_starred
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.kwarg_or_starred()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_110_cache = new HashMap<>();

    protected T[] _gather_110() {
        int p = this.mark();
        Memo<T[]> info = _gather_110_cache.get(p);
        if (info != null) {
            log("_gather_110() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_110() ...");
        this._level += 1;
        T[] result = __gather_110();
        this._level -= 1;
        log("_gather_110() [fresh]-> ", result);
        if (result != null) {
            _gather_110_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_110() {
        // _gather_110: kwarg_or_starred _loop0_111
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.kwarg_or_starred()) != null
                            &&
                            (seq = this._loop0_111()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop0_113_cache = new HashMap<>();

    protected T[] _loop0_113() {
        int p = this.mark();
        Memo<T[]> info = _loop0_113_cache.get(p);
        if (info != null) {
            log("_loop0_113() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_113() ...");
        this._level += 1;
        T[] result = __loop0_113();
        this._level -= 1;
        log("_loop0_113() [fresh]-> ", result);
        if (result != null) {
            _loop0_113_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_113() {
        // _loop0_113: ',' kwarg_or_double_starred
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.kwarg_or_double_starred()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_112_cache = new HashMap<>();

    protected T[] _gather_112() {
        int p = this.mark();
        Memo<T[]> info = _gather_112_cache.get(p);
        if (info != null) {
            log("_gather_112() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_112() ...");
        this._level += 1;
        T[] result = __gather_112();
        this._level -= 1;
        log("_gather_112() [fresh]-> ", result);
        if (result != null) {
            _gather_112_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_112() {
        // _gather_112: kwarg_or_double_starred _loop0_113
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.kwarg_or_double_starred()) != null
                            &&
                            (seq = this._loop0_113()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop0_115_cache = new HashMap<>();

    protected T[] _loop0_115() {
        int p = this.mark();
        Memo<T[]> info = _loop0_115_cache.get(p);
        if (info != null) {
            log("_loop0_115() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_115() ...");
        this._level += 1;
        T[] result = __loop0_115();
        this._level -= 1;
        log("_loop0_115() [fresh]-> ", result);
        if (result != null) {
            _loop0_115_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_115() {
        // _loop0_115: ',' kwarg_or_starred
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.kwarg_or_starred()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_114_cache = new HashMap<>();

    protected T[] _gather_114() {
        int p = this.mark();
        Memo<T[]> info = _gather_114_cache.get(p);
        if (info != null) {
            log("_gather_114() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_114() ...");
        this._level += 1;
        T[] result = __gather_114();
        this._level -= 1;
        log("_gather_114() [fresh]-> ", result);
        if (result != null) {
            _gather_114_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_114() {
        // _gather_114: kwarg_or_starred _loop0_115
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.kwarg_or_starred()) != null
                            &&
                            (seq = this._loop0_115()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop0_117_cache = new HashMap<>();

    protected T[] _loop0_117() {
        int p = this.mark();
        Memo<T[]> info = _loop0_117_cache.get(p);
        if (info != null) {
            log("_loop0_117() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_117() ...");
        this._level += 1;
        T[] result = __loop0_117();
        this._level -= 1;
        log("_loop0_117() [fresh]-> ", result);
        if (result != null) {
            _loop0_117_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_117() {
        // _loop0_117: ',' kwarg_or_double_starred
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.kwarg_or_double_starred()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_116_cache = new HashMap<>();

    protected T[] _gather_116() {
        int p = this.mark();
        Memo<T[]> info = _gather_116_cache.get(p);
        if (info != null) {
            log("_gather_116() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_116() ...");
        this._level += 1;
        T[] result = __gather_116();
        this._level -= 1;
        log("_gather_116() [fresh]-> ", result);
        if (result != null) {
            _gather_116_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_116() {
        // _gather_116: kwarg_or_double_starred _loop0_117
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.kwarg_or_double_starred()) != null
                            &&
                            (seq = this._loop0_117()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop0_118_cache = new HashMap<>();

    protected T[] _loop0_118() {
        int p = this.mark();
        Memo<T[]> info = _loop0_118_cache.get(p);
        if (info != null) {
            log("_loop0_118() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_118() ...");
        this._level += 1;
        T[] result = __loop0_118();
        this._level -= 1;
        log("_loop0_118() [fresh]-> ", result);
        if (result != null) {
            _loop0_118_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_118() {
        // _loop0_118: (',' star_target)
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T _tmp_137;
            while (
                    (_tmp_137 = this._tmp_137()) != null
            ) {
                children.add(_tmp_137);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _loop0_120_cache = new HashMap<>();

    protected T[] _loop0_120() {
        int p = this.mark();
        Memo<T[]> info = _loop0_120_cache.get(p);
        if (info != null) {
            log("_loop0_120() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_120() ...");
        this._level += 1;
        T[] result = __loop0_120();
        this._level -= 1;
        log("_loop0_120() [fresh]-> ", result);
        if (result != null) {
            _loop0_120_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_120() {
        // _loop0_120: ',' star_target
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.star_target()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_119_cache = new HashMap<>();

    protected T[] _gather_119() {
        int p = this.mark();
        Memo<T[]> info = _gather_119_cache.get(p);
        if (info != null) {
            log("_gather_119() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_119() ...");
        this._level += 1;
        T[] result = __gather_119();
        this._level -= 1;
        log("_gather_119() [fresh]-> ", result);
        if (result != null) {
            _gather_119_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_119() {
        // _gather_119: star_target _loop0_120
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.star_target()) != null
                            &&
                            (seq = this._loop0_120()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_121_cache = new HashMap<>();

    protected T _tmp_121() {
        int p = this.mark();
        Memo<T> info = _tmp_121_cache.get(p);
        if (info != null) {
            log("_tmp_121() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_121() ...");
        this._level += 1;
        T result = __tmp_121();
        this._level -= 1;
        log("_tmp_121() [fresh]-> ", result);
        if (result != null) {
            _tmp_121_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_121() {
        // _tmp_121: !'*' star_target
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T star_target;
            if (
                    this.negative_lookahead(this::expectStr, '*')
                            &&
                            (star_target = this.star_target()) != null
            ) {
                return star_target;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop0_123_cache = new HashMap<>();

    protected T[] _loop0_123() {
        int p = this.mark();
        Memo<T[]> info = _loop0_123_cache.get(p);
        if (info != null) {
            log("_loop0_123() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_123() ...");
        this._level += 1;
        T[] result = __loop0_123();
        this._level -= 1;
        log("_loop0_123() [fresh]-> ", result);
        if (result != null) {
            _loop0_123_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_123() {
        // _loop0_123: ',' del_target
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.del_target()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_122_cache = new HashMap<>();

    protected T[] _gather_122() {
        int p = this.mark();
        Memo<T[]> info = _gather_122_cache.get(p);
        if (info != null) {
            log("_gather_122() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_122() ...");
        this._level += 1;
        T[] result = __gather_122();
        this._level -= 1;
        log("_gather_122() [fresh]-> ", result);
        if (result != null) {
            _gather_122_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_122() {
        // _gather_122: del_target _loop0_123
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.del_target()) != null
                            &&
                            (seq = this._loop0_123()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T[]>> _loop0_125_cache = new HashMap<>();

    protected T[] _loop0_125() {
        int p = this.mark();
        Memo<T[]> info = _loop0_125_cache.get(p);
        if (info != null) {
            log("_loop0_125() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_125() ...");
        this._level += 1;
        T[] result = __loop0_125();
        this._level -= 1;
        log("_loop0_125() [fresh]-> ", result);
        if (result != null) {
            _loop0_125_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_125() {
        // _loop0_125: ',' target
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            Token literal;
            T elem;
            while (
                    (literal = this.expectStr(',')) != null
                            &&
                            (elem = this.target()) != null
            ) {
                children.add(elem);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, Memo<T[]>> _gather_124_cache = new HashMap<>();

    protected T[] _gather_124() {
        int p = this.mark();
        Memo<T[]> info = _gather_124_cache.get(p);
        if (info != null) {
            log("_gather_124() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_gather_124() ...");
        this._level += 1;
        T[] result = __gather_124();
        this._level -= 1;
        log("_gather_124() [fresh]-> ", result);
        if (result != null) {
            _gather_124_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __gather_124() {
        // _gather_124: target _loop0_125
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T elem;
            T[] seq;
            if (
                    (elem = this.target()) != null
                            &&
                            (seq = this._loop0_125()) != null
            ) {
                return ast.seq_insert_in_front(elem, seq);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_126_cache = new HashMap<>();

    protected T _tmp_126() {
        int p = this.mark();
        Memo<T> info = _tmp_126_cache.get(p);
        if (info != null) {
            log("_tmp_126() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_126() ...");
        this._level += 1;
        T result = __tmp_126();
        this._level -= 1;
        log("_tmp_126() [fresh]-> ", result);
        if (result != null) {
            _tmp_126_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_126() {
        // _tmp_126: star_targets '='
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T z;
            Token literal;
            if (
                    (z = this.star_targets()) != null
                            &&
                            (literal = this.expectStr('=')) != null
            ) {
                return z;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_127_cache = new HashMap<>();

    protected T _tmp_127() {
        int p = this.mark();
        Memo<T> info = _tmp_127_cache.get(p);
        if (info != null) {
            log("_tmp_127() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_127() ...");
        this._level += 1;
        T result = __tmp_127();
        this._level -= 1;
        log("_tmp_127() [fresh]-> ", result);
        if (result != null) {
            _tmp_127_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_127() {
        // _tmp_127: '.' | '...'
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            if (
                    (literal = this.expectStr('.')) != null
            ) {
                return ast.from_token(literal);
            }
            this.reset(mark);
        }
        {
            Token literal;
            if (
                    (literal = this.expectStr("...")) != null
            ) {
                return ast.from_token(literal);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_128_cache = new HashMap<>();

    protected T _tmp_128() {
        int p = this.mark();
        Memo<T> info = _tmp_128_cache.get(p);
        if (info != null) {
            log("_tmp_128() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_128() ...");
        this._level += 1;
        T result = __tmp_128();
        this._level -= 1;
        log("_tmp_128() [fresh]-> ", result);
        if (result != null) {
            _tmp_128_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_128() {
        // _tmp_128: '.' | '...'
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            if (
                    (literal = this.expectStr('.')) != null
            ) {
                return ast.from_token(literal);
            }
            this.reset(mark);
        }
        {
            Token literal;
            if (
                    (literal = this.expectStr("...")) != null
            ) {
                return ast.from_token(literal);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_129_cache = new HashMap<>();

    protected T _tmp_129() {
        int p = this.mark();
        Memo<T> info = _tmp_129_cache.get(p);
        if (info != null) {
            log("_tmp_129() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_129() ...");
        this._level += 1;
        T result = __tmp_129();
        this._level -= 1;
        log("_tmp_129() [fresh]-> ", result);
        if (result != null) {
            _tmp_129_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_129() {
        // _tmp_129: '@' named_expression NEWLINE
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T f;
            if (
                    (literal = this.expectStr('@')) != null
                            &&
                            (f = this.named_expression()) != null
                            &&
                            this.expect(TokenType.NEWLINE) != null
            ) {
                return f;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_130_cache = new HashMap<>();

    protected T _tmp_130() {
        int p = this.mark();
        Memo<T> info = _tmp_130_cache.get(p);
        if (info != null) {
            log("_tmp_130() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_130() ...");
        this._level += 1;
        T result = __tmp_130();
        this._level -= 1;
        log("_tmp_130() [fresh]-> ", result);
        if (result != null) {
            _tmp_130_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_130() {
        // _tmp_130: ',' star_expression
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T c;
            if (
                    (literal = this.expectStr(',')) != null
                            &&
                            (c = this.star_expression()) != null
            ) {
                return c;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_131_cache = new HashMap<>();

    protected T _tmp_131() {
        int p = this.mark();
        Memo<T> info = _tmp_131_cache.get(p);
        if (info != null) {
            log("_tmp_131() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_131() ...");
        this._level += 1;
        T result = __tmp_131();
        this._level -= 1;
        log("_tmp_131() [fresh]-> ", result);
        if (result != null) {
            _tmp_131_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_131() {
        // _tmp_131: ',' expression
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T c;
            if (
                    (literal = this.expectStr(',')) != null
                            &&
                            (c = this.expression()) != null
            ) {
                return c;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_132_cache = new HashMap<>();

    protected T _tmp_132() {
        int p = this.mark();
        Memo<T> info = _tmp_132_cache.get(p);
        if (info != null) {
            log("_tmp_132() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_132() ...");
        this._level += 1;
        T result = __tmp_132();
        this._level -= 1;
        log("_tmp_132() [fresh]-> ", result);
        if (result != null) {
            _tmp_132_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_132() {
        // _tmp_132: 'or' conjunction
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T c;
            if (
                    this.expectKeyword("or") != null
                            &&
                            (c = this.conjunction()) != null
            ) {
                return c;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_133_cache = new HashMap<>();

    protected T _tmp_133() {
        int p = this.mark();
        Memo<T> info = _tmp_133_cache.get(p);
        if (info != null) {
            log("_tmp_133() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_133() ...");
        this._level += 1;
        T result = __tmp_133();
        this._level -= 1;
        log("_tmp_133() [fresh]-> ", result);
        if (result != null) {
            _tmp_133_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_133() {
        // _tmp_133: 'and' inversion
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T c;
            if (
                    this.expectKeyword("and") != null
                            &&
                            (c = this.inversion()) != null
            ) {
                return c;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_134_cache = new HashMap<>();

    protected T _tmp_134() {
        int p = this.mark();
        Memo<T> info = _tmp_134_cache.get(p);
        if (info != null) {
            log("_tmp_134() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_134() ...");
        this._level += 1;
        T result = __tmp_134();
        this._level -= 1;
        log("_tmp_134() [fresh]-> ", result);
        if (result != null) {
            _tmp_134_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_134() {
        // _tmp_134: 'if' disjunction
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T z;
            if (
                    this.expectKeyword("if") != null
                            &&
                            (z = this.disjunction()) != null
            ) {
                return z;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_135_cache = new HashMap<>();

    protected T _tmp_135() {
        int p = this.mark();
        Memo<T> info = _tmp_135_cache.get(p);
        if (info != null) {
            log("_tmp_135() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_135() ...");
        this._level += 1;
        T result = __tmp_135();
        this._level -= 1;
        log("_tmp_135() [fresh]-> ", result);
        if (result != null) {
            _tmp_135_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_135() {
        // _tmp_135: 'if' disjunction
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T z;
            if (
                    this.expectKeyword("if") != null
                            &&
                            (z = this.disjunction()) != null
            ) {
                return z;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_136_cache = new HashMap<>();

    protected T _tmp_136() {
        int p = this.mark();
        Memo<T> info = _tmp_136_cache.get(p);
        if (info != null) {
            log("_tmp_136() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_136() ...");
        this._level += 1;
        T result = __tmp_136();
        this._level -= 1;
        log("_tmp_136() [fresh]-> ", result);
        if (result != null) {
            _tmp_136_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_136() {
        // _tmp_136: starred_expression | named_expression !'='
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            T starred_expression;
            if (
                    (starred_expression = this.starred_expression()) != null
            ) {
                return starred_expression;
            }
            this.reset(mark);
        }
        {
            T named_expression;
            if (
                    (named_expression = this.named_expression()) != null
                            &&
                            this.negative_lookahead(this::expectStr, '=')
            ) {
                return named_expression;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, Memo<T>> _tmp_137_cache = new HashMap<>();

    protected T _tmp_137() {
        int p = this.mark();
        Memo<T> info = _tmp_137_cache.get(p);
        if (info != null) {
            log("_tmp_137() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_tmp_137() ...");
        this._level += 1;
        T result = __tmp_137();
        this._level -= 1;
        log("_tmp_137() [fresh]-> ", result);
        if (result != null) {
            _tmp_137_cache.put(p, new Memo<>(result, this.mark()));
        }
        return result;
    }

    private T __tmp_137() {
        // _tmp_137: ',' star_target
        boolean cut = false;
        int mark = this.mark();
        int line_no = this.lineno();
        int col_offset = this.col_offset();
        {
            Token literal;
            T c;
            if (
                    (literal = this.expectStr(',')) != null
                            &&
                            (c = this.star_target()) != null
            ) {
                return c;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Set<String> _keywords = new HashSet<>(Arrays.asList(
            "False",
            "None",
            "True",
            "and",
            "as",
            "assert",
            "break",
            "class",
            "continue",
            "def",
            "del",
            "elif",
            "else",
            "except",
            "finally",
            "for",
            "from",
            "global",
            "if",
            "import",
            "in",
            "is",
            "lambda",
            "nonlocal",
            "not",
            "or",
            "pass",
            "raise",
            "return",
            "try",
            "while",
            "with",
            "yield"
    ));

    @Override
    protected boolean isKeyword(String name) {
        return _keywords.contains(name);
    }
}
