/*
 * @generated by pegen from data/cprog.gram
 */
package org.python.parser;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

class GeneratedParserSmall<T> extends Parser<T> {

    GeneratedParserSmall(Tokenizer tokenizer, String filename, boolean verbose, AstFactory<T> ast) {
        super(tokenizer, filename, verbose, ast);
    }

    private static class CachedInfo<T_> {
        public final T_ item;
        public int end_mark;

        CachedInfo(T_ item, int end_mark) {
            this.item = item;
            this.end_mark = end_mark;
        }

        @Override
        public String toString() {
            if (item != null)
                return item.toString() + ":~" + end_mark;
            else
                return "<null>:~" + end_mark;
        }
    }

    private final Map<Integer, CachedInfo<T>> start_cache = new HashMap<>();

    protected T start() {
        int p = this.mark();
        CachedInfo<T> info = start_cache.get(p);
        if (info != null) {
            log("start() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("start() ...");
        this._level += 1;
        T result = _start();
        this._level -= 1;
        log("start() [fresh]-> ", result);
        if (result != null) {
            start_cache.put(p, new CachedInfo<>(result, this.mark()));
        }
        return result;
    }

    private T _start() {
        // start: stmt* $
        boolean cut;
        int mark = this.mark();
        int lineno = this.lineno();
        int col_offset = this.col_offset();
        {
            T[] a;
            if (
                    (a = this._loop0_1()) != null
                            &&
                            this.expect(TokenType.ENDMARKER) != null
            ) {
                return ast.Module ( a, lineno, col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, CachedInfo<T>> stmt_cache = new HashMap<>();

    protected T stmt() {
        int p = this.mark();
        CachedInfo<T> info = stmt_cache.get(p);
        if (info != null) {
            log("stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("stmt() ...");
        this._level += 1;
        T result = _stmt();
        this._level -= 1;
        log("stmt() [fresh]-> ", result);
        if (result != null) {
            stmt_cache.put(p, new CachedInfo<>(result, this.mark()));
        }
        return result;
    }

    private T _stmt() {
        // stmt: compound_stmt | simple_stmt
        boolean cut;
        int mark = this.mark();
        int lineno = this.lineno();
        int col_offset = this.col_offset();
        {
            T compound_stmt;
            if (
                    (compound_stmt = this.compound_stmt()) != null
            ) {
                return compound_stmt;
            }
            this.reset(mark);
        }
        {
            T simple_stmt;
            if (
                    (simple_stmt = this.simple_stmt()) != null
            ) {
                return simple_stmt;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, CachedInfo<T>> compound_stmt_cache = new HashMap<>();

    protected T compound_stmt() {
        int p = this.mark();
        CachedInfo<T> info = compound_stmt_cache.get(p);
        if (info != null) {
            log("compound_stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("compound_stmt() ...");
        this._level += 1;
        T result = _compound_stmt();
        this._level -= 1;
        log("compound_stmt() [fresh]-> ", result);
        if (result != null) {
            compound_stmt_cache.put(p, new CachedInfo<>(result, this.mark()));
        }
        return result;
    }

    private T _compound_stmt() {
        // compound_stmt: pass_stmt | if_stmt
        boolean cut;
        int mark = this.mark();
        int lineno = this.lineno();
        int col_offset = this.col_offset();
        {
            T pass_stmt;
            if (
                    (pass_stmt = this.pass_stmt()) != null
            ) {
                return pass_stmt;
            }
            this.reset(mark);
        }
        {
            T if_stmt;
            if (
                    (if_stmt = this.if_stmt()) != null
            ) {
                return if_stmt;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, CachedInfo<T>> pass_stmt_cache = new HashMap<>();

    protected T pass_stmt() {
        int p = this.mark();
        CachedInfo<T> info = pass_stmt_cache.get(p);
        if (info != null) {
            log("pass_stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("pass_stmt() ...");
        this._level += 1;
        T result = _pass_stmt();
        this._level -= 1;
        log("pass_stmt() [fresh]-> ", result);
        if (result != null) {
            pass_stmt_cache.put(p, new CachedInfo<>(result, this.mark()));
        }
        return result;
    }

    private T _pass_stmt() {
        // pass_stmt: 'pass' NEWLINE
        boolean cut;
        int mark = this.mark();
        int lineno = this.lineno();
        int col_offset = this.col_offset();
        {
            Token a;
            if (
                    (a = this.expectKeyword("pass")) != null
                            &&
                            this.expect(TokenType.NEWLINE) != null
            ) {
                return ast.Pass ( lineno, col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, CachedInfo<T>> if_stmt_cache = new HashMap<>();

    protected T if_stmt() {
        int p = this.mark();
        CachedInfo<T> info = if_stmt_cache.get(p);
        if (info != null) {
            log("if_stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("if_stmt() ...");
        this._level += 1;
        T result = _if_stmt();
        this._level -= 1;
        log("if_stmt() [fresh]-> ", result);
        if (result != null) {
            if_stmt_cache.put(p, new CachedInfo<>(result, this.mark()));
        }
        return result;
    }

    private T _if_stmt() {
        // if_stmt: 'if' expression ':' suite else_clause?
        boolean cut;
        int mark = this.mark();
        int lineno = this.lineno();
        int col_offset = this.col_offset();
        {
            T c;
            T[] t;
            T[] e;
            if (
                    this.expectKeyword("if") != null
                            &&
                            (c = this.expression()) != null
                            &&
                            this.expectStr(':') != null
                            &&
                            (t = this.suite()) != null
                            &&
                            ((e = this.else_clause()) != null || true)
            ) {
                return ast.If ( c , t , e , lineno, col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, CachedInfo<T[]>> else_clause_cache = new HashMap<>();

    protected T[] else_clause() {
        int p = this.mark();
        CachedInfo<T[]> info = else_clause_cache.get(p);
        if (info != null) {
            log("else_clause() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("else_clause() ...");
        this._level += 1;
        T[] result = _else_clause();
        this._level -= 1;
        log("else_clause() [fresh]-> ", result);
        if (result != null) {
            else_clause_cache.put(p, new CachedInfo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _else_clause() {
        // else_clause: 'elif' expression ':' suite else_clause? | 'else' ':' suite
        boolean cut;
        int mark = this.mark();
        int lineno = this.lineno();
        int col_offset = this.col_offset();
        {
            T c;
            T[] t;
            T[] e;
            if (
                    this.expectKeyword("elif") != null
                            &&
                            (c = this.expression()) != null
                            &&
                            this.expectStr(':') != null
                            &&
                            (t = this.suite()) != null
                            &&
                            ((e = this.else_clause()) != null || true)
            ) {
                return ast.singleton_seq ( ast.If ( c , t , e , lineno, col_offset ) );
            }
            this.reset(mark);
        }
        {
            T[] s;
            if (
                    this.expectKeyword("else") != null
                            &&
                            this.expectStr(':') != null
                            &&
                            (s = this.suite()) != null
            ) {
                return s;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, CachedInfo<T[]>> suite_cache = new HashMap<>();

    protected T[] suite() {
        int p = this.mark();
        CachedInfo<T[]> info = suite_cache.get(p);
        if (info != null) {
            log("suite() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("suite() ...");
        this._level += 1;
        T[] result = _suite();
        this._level -= 1;
        log("suite() [fresh]-> ", result);
        if (result != null) {
            suite_cache.put(p, new CachedInfo<>(result, this.mark()));
        }
        return result;
    }

    private T[] _suite() {
        // suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT
        boolean cut;
        int mark = this.mark();
        int lineno = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            if (
                    (a = this.simple_stmt()) != null
            ) {
                return ast.singleton_seq ( a );
            }
            this.reset(mark);
        }
        {
            T[] b;
            if (
                    this.expect(TokenType.NEWLINE) != null
                            &&
                            this.expect(TokenType.INDENT) != null
                            &&
                            (b = this._loop1_2()) != null
                            &&
                            this.expect(TokenType.DEDENT) != null
            ) {
                return b;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, CachedInfo<T>> simple_stmt_cache = new HashMap<>();

    protected T simple_stmt() {
        int p = this.mark();
        CachedInfo<T> info = simple_stmt_cache.get(p);
        if (info != null) {
            log("simple_stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("simple_stmt() ...");
        this._level += 1;
        T result = _simple_stmt();
        this._level -= 1;
        log("simple_stmt() [fresh]-> ", result);
        if (result != null) {
            simple_stmt_cache.put(p, new CachedInfo<>(result, this.mark()));
        }
        return result;
    }

    private T _simple_stmt() {
        // simple_stmt: expr_stmt NEWLINE
        boolean cut;
        int mark = this.mark();
        int lineno = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            if (
                    (a = this.expr_stmt()) != null
                            &&
                            this.expect(TokenType.NEWLINE) != null
            ) {
                return a;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, CachedInfo<T>> expr_stmt_cache = new HashMap<>();

    protected T expr_stmt() {
        int p = this.mark();
        CachedInfo<T> info = expr_stmt_cache.get(p);
        if (info != null) {
            log("expr_stmt() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("expr_stmt() ...");
        this._level += 1;
        T result = _expr_stmt();
        this._level -= 1;
        log("expr_stmt() [fresh]-> ", result);
        if (result != null) {
            expr_stmt_cache.put(p, new CachedInfo<>(result, this.mark()));
        }
        return result;
    }

    private T _expr_stmt() {
        // expr_stmt: expression
        boolean cut;
        int mark = this.mark();
        int lineno = this.lineno();
        int col_offset = this.col_offset();
        {
            T a;
            if (
                    (a = this.expression()) != null
            ) {
                return ast.Expr ( a , lineno, col_offset );
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, CachedInfo<T>> expression_cache = new HashMap<>();

    protected T expression() {
        int p = this.mark();
        CachedInfo<T> info = expression_cache.get(p);
        if (info != null) {
            log("expression() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("expression() ...");
        T last_result = null;
        int last_mark = p;
        int depth = 0;
        expression_cache.put(p, new CachedInfo<>(null, p));
        log("recursive expression() at " + p + " depth " + depth);
        while (true) {
            this.reset(p);
            this._level += 1;
            T result = _expression();
            int end_mark = this.mark();
            depth += 1;
            this._level -= 1;
            log("recursive expression() at " + p + " depth " + depth + ": ", result);
            if (result == null || end_mark <= last_mark)
                break;
            last_result = result;
            last_mark = end_mark;
            expression_cache.put(p, new CachedInfo<>(result, end_mark));
        }
        this.reset(last_mark);
        if (last_result != null) {
            last_mark = this.mark();
        } else {
            last_mark = p;
            this.reset(last_mark);
        }
        log("expression() [fresh]-> ", last_result);
        expression_cache.put(p, new CachedInfo<>(last_result, last_mark));
        return last_result;
    }

    private T _expression() {
        // expression: expression '+' term | expression '-' term | term
        boolean cut;
        int mark = this.mark();
        int lineno = this.lineno();
        int col_offset = this.col_offset();
        {
            T l;
            T r;
            if (
                    (l = this.expression()) != null
                            &&
                            this.expectStr('+') != null
                            &&
                            (r = this.term()) != null
            ) {
                return ast.BinOp ( l , ast.Add() , r , lineno, col_offset );
            }
            this.reset(mark);
        }
        {
            T l;
            T r;
            if (
                    (l = this.expression()) != null
                            &&
                            this.expectStr('-') != null
                            &&
                            (r = this.term()) != null
            ) {
                return ast.BinOp ( l , ast.Sub() , r , lineno, col_offset );
            }
            this.reset(mark);
        }
        {
            T term;
            if (
                    (term = this.term()) != null
            ) {
                return term;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, CachedInfo<T>> term_cache = new HashMap<>();

    protected T term() {
        int p = this.mark();
        CachedInfo<T> info = term_cache.get(p);
        if (info != null) {
            log("term() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("term() ...");
        T last_result = null;
        int last_mark = p;
        int depth = 0;
        term_cache.put(p, new CachedInfo<>(null, p));
        log("recursive term() at " + p + " depth " + depth);
        while (true) {
            this.reset(p);
            this._level += 1;
            T result = _term();
            int end_mark = this.mark();
            depth += 1;
            this._level -= 1;
            log("recursive term() at " + p + " depth " + depth + ": ", result);
            if (result == null || end_mark <= last_mark)
                break;
            last_result = result;
            last_mark = end_mark;
            term_cache.put(p, new CachedInfo<>(result, end_mark));
        }
        this.reset(last_mark);
        if (last_result != null) {
            last_mark = this.mark();
        } else {
            last_mark = p;
            this.reset(last_mark);
        }
        log("term() [fresh]-> ", last_result);
        term_cache.put(p, new CachedInfo<>(last_result, last_mark));
        return last_result;
    }

    private T _term() {
        // term: term '*' factor | term '/' factor | factor
        boolean cut;
        int mark = this.mark();
        int lineno = this.lineno();
        int col_offset = this.col_offset();
        {
            T l;
            T r;
            if (
                    (l = this.term()) != null
                            &&
                            this.expectStr('*') != null
                            &&
                            (r = this.factor()) != null
            ) {
                return ast.BinOp ( l , ast.Mult() , r , lineno, col_offset );
            }
            this.reset(mark);
        }
        {
            T l;
            T r;
            if (
                    (l = this.term()) != null
                            &&
                            this.expectStr('/') != null
                            &&
                            (r = this.factor()) != null
            ) {
                return ast.BinOp ( l , ast.Div() , r , lineno, col_offset );
            }
            this.reset(mark);
        }
        {
            T factor;
            if (
                    (factor = this.factor()) != null
            ) {
                return factor;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, CachedInfo<T>> factor_cache = new HashMap<>();

    protected T factor() {
        int p = this.mark();
        CachedInfo<T> info = factor_cache.get(p);
        if (info != null) {
            log("factor() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("factor() ...");
        this._level += 1;
        T result = _factor();
        this._level -= 1;
        log("factor() [fresh]-> ", result);
        if (result != null) {
            factor_cache.put(p, new CachedInfo<>(result, this.mark()));
        }
        return result;
    }

    private T _factor() {
        // factor: primary '**' factor | primary
        boolean cut;
        int mark = this.mark();
        int lineno = this.lineno();
        int col_offset = this.col_offset();
        {
            T l;
            T r;
            if (
                    (l = this.primary()) != null
                            &&
                            this.expectStr("**") != null
                            &&
                            (r = this.factor()) != null
            ) {
                return ast.BinOp ( l , ast.Pow() , r , lineno, col_offset );
            }
            this.reset(mark);
        }
        {
            T primary;
            if (
                    (primary = this.primary()) != null
            ) {
                return primary;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, CachedInfo<T>> primary_cache = new HashMap<>();

    protected T primary() {
        int p = this.mark();
        CachedInfo<T> info = primary_cache.get(p);
        if (info != null) {
            log("primary() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("primary() ...");
        T last_result = null;
        int last_mark = p;
        int depth = 0;
        primary_cache.put(p, new CachedInfo<>(null, p));
        log("recursive primary() at " + p + " depth " + depth);
        while (true) {
            this.reset(p);
            this._level += 1;
            T result = _primary();
            int end_mark = this.mark();
            depth += 1;
            this._level -= 1;
            log("recursive primary() at " + p + " depth " + depth + ": ", result);
            if (result == null || end_mark <= last_mark)
                break;
            last_result = result;
            last_mark = end_mark;
            primary_cache.put(p, new CachedInfo<>(result, end_mark));
        }
        this.reset(last_mark);
        if (last_result != null) {
            last_mark = this.mark();
        } else {
            last_mark = p;
            this.reset(last_mark);
        }
        log("primary() [fresh]-> ", last_result);
        primary_cache.put(p, new CachedInfo<>(last_result, last_mark));
        return last_result;
    }

    private T _primary() {
        // primary: primary '(' expression ')' | atom
        boolean cut;
        int mark = this.mark();
        int lineno = this.lineno();
        int col_offset = this.col_offset();
        {
            T f;
            T e;
            if (
                    (f = this.primary()) != null
                            &&
                            this.expectStr('(') != null
                            &&
                            (e = this.expression()) != null
                            &&
                            this.expectStr(')') != null
            ) {
                return ast.Call ( f , ast.singleton_seq ( e ) , null , lineno, col_offset );
            }
            this.reset(mark);
        }
        {
            T atom;
            if (
                    (atom = this.atom()) != null
            ) {
                return atom;
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, CachedInfo<T>> atom_cache = new HashMap<>();

    protected T atom() {
        int p = this.mark();
        CachedInfo<T> info = atom_cache.get(p);
        if (info != null) {
            log("atom() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("atom() ...");
        this._level += 1;
        T result = _atom();
        this._level -= 1;
        log("atom() [fresh]-> ", result);
        if (result != null) {
            atom_cache.put(p, new CachedInfo<>(result, this.mark()));
        }
        return result;
    }

    private T _atom() {
        // atom: '(' expression ')' | NAME | NUMBER | STRING
        boolean cut;
        int mark = this.mark();
        int lineno = this.lineno();
        int col_offset = this.col_offset();
        {
            T e;
            if (
                    this.expectStr('(') != null
                            &&
                            (e = this.expression()) != null
                            &&
                            this.expectStr(')') != null
            ) {
                return e;
            }
            this.reset(mark);
        }
        {
            T name;
            if (
                    (name = this.name()) != null
            ) {
                return name;
            }
            this.reset(mark);
        }
        {
            Token number;
            if (
                    (number = this.number()) != null
            ) {
                return ast.from_token(number);
            }
            this.reset(mark);
        }
        {
            Token string;
            if (
                    (string = this.string()) != null
            ) {
                return ast.from_token(string);
            }
            this.reset(mark);
        }
        return null;
    }

    private final Map<Integer, CachedInfo<T[]>> _loop0_1_cache = new HashMap<>();

    protected T[] _loop0_1() {
        int p = this.mark();
        CachedInfo<T[]> info = _loop0_1_cache.get(p);
        if (info != null) {
            log("_loop0_1() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop0_1() ...");
        this._level += 1;
        T[] result = __loop0_1();
        this._level -= 1;
        log("_loop0_1() [fresh]-> ", result);
        if (result != null) {
            _loop0_1_cache.put(p, new CachedInfo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop0_1() {
        // _loop0_1: stmt
        boolean cut;
        int mark = this.mark();
        int lineno = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T stmt;
            while (
                    (stmt = this.stmt()) != null
            ) {
                children.add(stmt);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Map<Integer, CachedInfo<T[]>> _loop1_2_cache = new HashMap<>();

    protected T[] _loop1_2() {
        int p = this.mark();
        CachedInfo<T[]> info = _loop1_2_cache.get(p);
        if (info != null) {
            log("_loop1_2() [cached]-> " + info.toString());
            this.reset(info.end_mark);
            return info.item;
        }
        logl("_loop1_2() ...");
        this._level += 1;
        T[] result = __loop1_2();
        this._level -= 1;
        log("_loop1_2() [fresh]-> ", result);
        if (result != null) {
            _loop1_2_cache.put(p, new CachedInfo<>(result, this.mark()));
        }
        return result;
    }

    private T[] __loop1_2() {
        // _loop1_2: stmt
        boolean cut;
        int mark = this.mark();
        int lineno = this.lineno();
        int col_offset = this.col_offset();
        List<T> children = new ArrayList<>();
        {
            T stmt;
            while (
                    (stmt = this.stmt()) != null
            ) {
                children.add(stmt);
                mark = this.mark();
            }
            this.reset(mark);
        }
        return ast.to_seq(children);
    }

    private final Set<String> _keywords = new HashSet<>(Arrays.asList(
            "elif",
            "else",
            "if",
            "pass"
    ));

    @Override
    protected boolean isKeyword(String name) {
        return _keywords.contains(name);
    }
}
